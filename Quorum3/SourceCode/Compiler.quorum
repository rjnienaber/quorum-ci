package Libraries.Language.Compile

use Libraries.System.File
use Libraries.Language.Compile.Symbol.all
use Libraries.Containers.HashTable
use Libraries.Containers.Array
use Libraries.Containers.Blueprints.Iterator
use Libraries.Language.Compile.Translate.QuorumJarGenerator
use Libraries.Containers.List

class Compiler
    public constant number VERSION = 3.0
    File main = undefined
    constant text DEFAULT_BUILD_FOLDER = "TestBuild"
    constant text DEFAULT_RUN_FOLDER = "TestRun"
    constant text DEFAULT_STANDARD_LIBRARY_FOLDER = "Library/Standard"
    File buildFolder = undefined
    File runFolder = undefined
    File standardLibraryFolder = undefined
    HashTable<text, Dependency> dependencies

    boolean isWebApplication = false
    text name = "Default"

    //Support classes
    SymbolTable symbolTable
    CompilerErrorManager compilerErrorManager
    TypeChecker checker

    on create //load default dependencies
        standardLibraryFolder = GetStandardLibraryFolder()
        LoadDependency("/quorum", "/quorum")
        //LoadDependency("/plugins", "/plugins")
        //LoadDependency("/antlr", "/antlr")
        //LoadDependency("/asm", "/asm")
    end

    action LoadDependency(text from, text to)
        Dependency dep
        dep:from = from
        dep:to = to
        dependencies:Add(from, dep)
    end

    action GetDependencies returns Iterator<Dependency>
        return dependencies:GetValueIterator()
    end

    /*
        This action compiles the array of files to Java Bytecode, which
        it writes to disk. By default, it generates a .jar file into the 
        folder named Run and the class files into the folder labeled
        Build.
    */
    action Compile(Array<File> files)

        i = 0
        repeat while i < files:GetSize()
            File file = files:Get(i)
            Parser listener
            Parse(file, listener)
            i = i + 1
        end
        
        //This array will contain all files that must be built, 
        //including potentially some from the standard library
        //in order to build the requested files
        Array<File> allFiles = GetAllRequiredFiles()
        ResolveAllParents()
        i = 0
        repeat while i < allFiles:GetSize()
            File file = allFiles:Get(i)
            TypeCheckListener listener
            Parse(file, listener)
            i = i + 1
        end

        i = 0
        repeat while i < allFiles:GetSize()
            File file = allFiles:Get(i)
            QuorumBytecodeListener listener
            Parse(file, listener)
            i = i + 1
        end

        if compilerErrorManager:IsCompilationErrorFree()
            QuorumJarGenerator generator
            File jar = GetDistributionFile()
            generator:SetCompiler(me)
            generator:Write()
        end
    end

    action ResolveAllParents
        Iterator<Class> classes = symbolTable:GetClasses()
        repeat while classes:HasNext()
            Class next = classes:Next()

            //because of the way the parent flattening algorithm works,
            //parents may already be resolved. As such, if this has already
            //happened, we can ignore these, as their errors are already
            //accounted for.
            if not next:AreParentsResolved()
                Array<CompilerError> errors = next:ResolveParents(symbolTable)
                i = 0
                repeat errors:GetSize() times
                    CompilerError error = errors:Get(i)
                    compilerErrorManager:Add(error)
                    i = i + 1
                end
            end
        end
    end

    action IsCompilationErrorFree returns boolean
        return compilerErrorManager:IsCompilationErrorFree()
    end

    action OutputCompilerErrors
        output "The code did not build correctly. Here is a list of errors:"
        Iterator<CompilerError> errors = compilerErrorManager:GetIterator()
        repeat while errors:HasNext()
            CompilerError error = errors:Next()
            text t = error:GetDisplayName()
            output t
        end
    end

    /*
        This action is called after the parsing phase, returning an array
        of all files were required for building the project.
    */
    action GetAllRequiredFiles returns Array<File>
        Array<File> files

        HashTable<text, File> parsed
        HashTable<text, File> unparsed

        Iterator<Class> classes = symbolTable:GetClasses()
        repeat while classes:HasNext()
            //gather up all the classes on the system and check their
            //use statements for classes we don't know about
            //if there are some, mark them as unparsed
            repeat while classes:HasNext()
                Class clazz = classes:Next()
                File classFile = clazz:GetFile()
                text path = classFile:GetAbsolutePath()
                if not parsed:HasKey(path)
                    parsed:Add(path, clazz:GetFile())
                end
                Iterator<QualifiedName> names = clazz:GetUnresolvedUseStatements()
                ResolveQualifiedNames(names, parsed, unparsed, clazz)

                Iterator<QualifiedName> parents = clazz:GetUnresolvedParents()
                ResolveParents(parents, parsed, unparsed, clazz)
            end

            //make list of any new classes that need to be analyzed
            //that have not previously been parsed. If there are some
            //send them back through the loop
            List<Class> newClasses
            Iterator<File> mustParse = unparsed:GetValueIterator()
            repeat while mustParse:HasNext()
                File next = mustParse:Next()
                Parser listener
                Parse(next, listener)
                parsed:Add(next:GetAbsolutePath(), next)

                Iterator<Class> parsedClasses = listener:GetClassesIterator()
                repeat while parsedClasses:HasNext()
                    Class clazz = parsedClasses:Next()
                    newClasses:Add(clazz)
                    if not symbolTable:HasClass(clazz:GetStaticKey())
                        symbolTable:Add(clazz)
                    end
                end
            end
            classes = newClasses:GetIterator()
            unparsed:Empty()
        end
        return parsed:CopyToValueArray()
    end

    private action ResolveParents(Iterator<QualifiedName> names, 
            HashTable<text, File> parsed,
            HashTable<text, File> unparsed, Class clazz)


        repeat while names:HasNext()
            QualifiedName qn = names:Next()
            text key = qn:GetStaticKey()
            Class classCheck = clazz:GetValidUseName(key)

            //is there a class of that name in the same package?
            if classCheck = undefined
                text pack = clazz:GetPackageKey()
                classCheck = symbolTable:GetClassInPackage(pack, qn:GetName())
            end
            
            //Is there a class with a fully qualified name in the symbol table?
            if classCheck = undefined
                classCheck =  symbolTable:GetClass(key) //is it in the symbol table?
            end

            if classCheck = undefined //ignore it if it exists already
                File file = GetStandardLibraryFile(key)
                if file not= undefined
                    text newPath = file:GetAbsolutePath()
                    if parsed:HasKey(newPath) //this class has already been parsed
                    elseif unparsed:HasKey(newPath) //this class is already scheduled for parsing
                    else
                        unparsed:Add(newPath, file)
                    end
                else//this should be a compiler error. The user requested a file that doesn't exist
                    CompilerError error
                    error:SetLocation(qn)
                    CompilerErrorType type
                    type:SetCurrentType(type:MISSING_CLASS)
                    error:SetCompilerErrorType(type)
                    error:SetErrorMessage("I noticed that this class is a " + key + ", but I cannot find it." 
                        + " Did you forget to tell me about it or put it in the standard library?")
                    compilerErrorManager:Add(error)
                end
            end
        end
    end

    private action ResolveQualifiedNames(
            Iterator<QualifiedName> names, 
            HashTable<text, File> parsed,
            HashTable<text, File> unparsed, Class clazz)
        repeat while names:HasNext()
            QualifiedName qn = names:Next()
            text key = qn:GetStaticKey()
            Class classCheck =  symbolTable:GetClass(key)
            if classCheck = undefined //ignore it if it exists already
                File file = GetStandardLibraryFile(key)
                if file not= undefined
                    text newPath = file:GetAbsolutePath()
                    if parsed:HasKey(newPath) //this class has already been parsed
                        Class newClass = symbolTable:GetClassInFile(newPath)
                        clazz:AddValidUse(newClass)
                    elseif unparsed:HasKey(newPath) //this class is already scheduled for parsing

                    else
                        unparsed:Add(newPath, file)
                    end
                else//this should be a compiler error. The user requested a file that doesn't exist
                    CompilerError error
                    error:SetLocation(qn)
                    CompilerErrorType type
                    type:SetCurrentType(type:MISSING_CLASS)
                    error:SetCompilerErrorType(type)
                    error:SetErrorMessage("I could not find a class named " + key + "." 
                        + " Did you forget to tell me about it or put it in the standard library?")
                    compilerErrorManager:Add(error)
                end
            else
                clazz:AddValidUse(classCheck)
            end
        end
    end

    action GetStandardLibraryFile(text key) returns File
        Array<text> values = key:Split("\.")
        text loc = standardLibraryFolder:GetWorkingDirectory()
        text loc2 = standardLibraryFolder:GetAbsolutePath()

        File file
        file:SetWorkingDirectory(loc2)

        text location = "/"
        Iterator<text> it = values:GetIterator()
        repeat while it:HasNext()
            text next = it:Next()
            location = location + next

            if it:HasNext()
                location = location + "/"
            else
                location = location + ".quorum"
            end
        end

        file:SetPath(location)
        if file:Exists()
            return file
        end

        return undefined
    end

    action CompileToJavaScript(Array<File> files)

    end

    action Parse(File file, QuorumSourceListener listener)
        listener:SetSymbolTable(symbolTable)
        listener:SetCompilerErrorManager(compilerErrorManager)
        listener:SetFile(file)
        listener:SetTypeChecker(checker)
        ParseNative(file, listener)
    end

    private system action ParseNative(File file, QuorumSourceListener listener)


    action Parse(text source, QuorumSourceListener listener)
        listener:SetSymbolTable(symbolTable)
        listener:SetCompilerErrorManager(compilerErrorManager)
        listener:SetTypeChecker(checker)
        File file //set a default. It doesn't matter what it is.
        listener:SetFile(file)
        ParseNative(source, listener)
    end

    private system action ParseNative(text source, QuorumSourceListener listener)

    action GetName returns text
        return name
    end

    action GetNameWithExtension returns text
        return name + GetFileExtension()
    end

    action SetName(text name)
        me:name = name
    end

    action GetFileExtension returns text
        if IsWebApplication()
            return ".war"
        else
            return ".jar"
        end
    end

    action GetMain returns File
        return main
    end

    action GetMainClass returns Class
        Class c = symbolTable:GetClassInFile(main:GetAbsolutePath())
        return c
    end

    action SetMain(File file)
        main = file
    end

    action GetVersion returns text
        return "Quorum " + VERSION
    end

    action GetBuildFolder returns File
        if buildFolder = undefined
            File build
            build:SetPath(DEFAULT_BUILD_FOLDER)
            buildFolder = build
        end
        return buildFolder
    end

    action GetStandardLibraryFolder returns File
        if standardLibraryFolder = undefined
            File build
            build:SetPath(DEFAULT_STANDARD_LIBRARY_FOLDER)
            return build
        end
        return standardLibraryFolder
    end

    action SetStandardLibraryFolder(File file)
        standardLibraryFolder = file
    end

    action GetDistributionFile returns File
        File run = GetRunFolder()
        text path = run:GetPath() + "/"
        File newRun
        
        newRun:SetPath(path + GetNameWithExtension())
        return newRun
    end

    action SetBuildFolder(File file)
        buildFolder = file
    end

    action GetRunFolder returns File
        if runFolder = undefined
            File run
            run:SetPath(DEFAULT_RUN_FOLDER)
            runFolder = run
        end
        return runFolder
    end

    action SetRunFolder(File file)
        runFolder = file
    end

    action IsWebApplication returns boolean
        return isWebApplication
    end

    action SetIsWebApplication(boolean web)
        isWebApplication = web
    end
end