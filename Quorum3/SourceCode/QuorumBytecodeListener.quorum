package Libraries.Language.Compile

use Libraries.Language.Compile.Context.all
use Libraries.Language.Compile.Translate.JavaBytecodeClassWriter
use Libraries.Language.Compile.Translate.JavaBytecodeMethodWriter
use Libraries.Language.Compile.Translate.QuorumBytecodeConverter
use Libraries.Language.Compile.Translate.JavaBytecodeOpcodes
use Libraries.Language.Compile.Symbol.all
use Libraries.Language.Compile.Translate.all

use Libraries.Containers.Array
use Libraries.Containers.List
use Libraries.Containers.HashTable
use Libraries.Containers.Blueprints.Iterator
use Libraries.System.File
use Libraries.Containers.Stack

class QuorumBytecodeListener is QuorumSourceListener 
    QualifiedName packageValue = undefined
    JavaBytecodeClassWriter classWriter = undefined
    JavaBytecodeClassWriter interfaceWriter = undefined
    JavaBytecodeMethodWriter methodWriter = undefined
    JavaBytecodeMethodWriter interfaceMethodWriter = undefined

    QuorumBytecodeConverter converter
    JavaBytecodeOpcodes opcodes
    Action currentAction = undefined
    ActionOpcode currentActionOpcode = undefined
    ClassOpcode currentClassOpcode = undefined
    boolean isInAction = false

    Class currentClass = undefined
    Block currentBlock = undefined
    Block recentlyPoppedBlock = undefined
    constant integer ME = 0
    text build = "TestBuild"
    text run = "TestRun"
    constant text QUORUM = "quorum"

    constant text JAVA_THROWABLE = "java/lang/Throwable"
    constant text JAVA_OBJECT = "java/lang/Object"
    constant text QUORUM_ERROR = "quorum/Libraries/Language/Errors/Error"
    boolean isNormalAction = false
    boolean isSystemAction = false
    boolean isBluePrintAction = false
    boolean isNextVariableReferenceMe = false
    Stack<QuorumOpcode> opcodeStack
    Stack<CheckDetectOpcode> checkStack
    Stack<ConditionalOpcode> ifStack
    Stack<LoopOpcode> loopStack
    Stack<ParentVariableFunctionCallContext> parentCallStack
    File buildFile = undefined
    File buildInterfaceFile = undefined
    BlockOpcode currentBlockOpcode = undefined
    Stack<BlockOpcode> poppedBlockOpcodes
    Stack<BlockOpcode> currentBlocks
    Stack<integer> blockPositionStack
    Stack<ActionExpressionListContext> actionCallParameterStack
    HashTable<integer, Array<ActionCallOpcode>> actionCallStacks
    integer currentActionStack = 0
    integer loopCounter = 0
    integer ifCount = 0
    integer checkCount = 0
    boolean outputSpeechCommands = true

    action GetClassOpcode returns ClassOpcode
        return currentClassOpcode
    end

    action GetBuildFile returns File
        return buildFile
    end

    action GetBuildInterfaceFile returns File
        return buildInterfaceFile
    end

    action SetOutputSpeech(boolean doSay)
        outputSpeechCommands = doSay
    end

    action GetOutputSpeech returns boolean
        return outputSpeechCommands
    end
    
    private action SetNormalAction 
        isNormalAction = true
        isSystemAction = false
        isBluePrintAction = false
    end

    private action SetSystemAction 
        isNormalAction = false
        isSystemAction = true
        isBluePrintAction = false
    end

    private action SetBlueprintAction 
        isNormalAction = false
        isSystemAction = false
        isBluePrintAction = true
    end

    private action ClearActionState
        isNormalAction = false
        isSystemAction = false
        isBluePrintAction = false
    end

    action ExitPackageRule(PackageContext context) 
        packageValue = context:name
    end

    action EnterFullClassDeclaration(FullClassDeclarationContext context) 
        AddClass(context:className)
    end

    action AddClass(text className) 
        JavaBytecodeClassWriter newClassWriter
        JavaBytecodeClassWriter newIinterfaceWriter

        classWriter = newClassWriter
        interfaceWriter = newIinterfaceWriter
        ClassOpcode classOp
        currentClassOpcode = classOp

        text name = className
        SymbolTable table = me:GetSymbolTable()
        
        text staticKey = ""
        if packageValue = undefined
            QualifiedName default
            packageValue = default
        end
        staticKey = packageValue:GetClassStaticKey(name)
        currentClass = table:GetClass(staticKey)
        currentClassOpcode:SetClass(currentClass)
        currentClassOpcode:SetName(name)
        currentClassOpcode:SetStaticKey(staticKey)
        currentClassOpcode:SetBuildPath(build)
        currentClassOpcode:SetRunPath(run)
        currentClassOpcode:SetPackage(packageValue)
        currentClassOpcode:SetClassWriter(classWriter)
        currentClassOpcode:SetInterfaceWriter(interfaceWriter)
    end

    action EnterNoActionsNoClass(NoActionsNoClassContext context) 
        File file = GetFile()
        text name = file:GetFileName()
        text extension = file:GetFileExtension()
        integer length = extension:GetSize()
        name = name:GetSubtext(0, name:GetSize() - length - 1)
        AddClass(name)


        if currentClass not= undefined
            //get the method name
            Array<Variable> vars
            Iterator<Variable> paramIt = vars:GetIterator()
            text key = currentClass:ResolveActionKey("Main", paramIt,
                GetSymbolTable(), GetCompilerErrorManager())

            Action method = currentClass:GetAction(key)
            currentAction = method
            ActionOpcode actionOpcode
            currentActionOpcode = actionOpcode
            currentActionOpcode:SetAction(method)
            currentActionOpcode:SetClass(currentClass)

            boolean isMain = method:IsMain()
            text null = undefined
            text actionName = method:GetName()
            text params = method:ConvertActionToBytecodeParameterInterfaceSignature()
            methodWriter = 
                classWriter:VisitMethod(opcodes:GetPublic(), 
                actionName, params, null, undefined)
            currentActionOpcode:SetMethodWriter(methodWriter)
            currentClassOpcode:Add(currentActionOpcode)


            BlockContext b
            Location loc = b:GetLocation()
            loc:SetLocation(context:GetLocation())
            EnterBlock(b)
            isInAction = true
        end
    end

    action EnterActionsNoClass(ActionsNoClassContext context) 
        File file = GetFile()
        text name = file:GetFileName()
        text extension = file:GetFileExtension()
        integer length = extension:GetSize()
        name = name:GetSubtext(0, name:GetSize() - length - 1)
        AddClass(name)
    end

    action ExitActionsNoClass(ActionsNoClassContext context) 
        ExitClass()
    end

    action ExitNoActionsNoClass(NoActionsNoClassContext context) 
        BlockContext b
        Location loc = b:GetLocation()
        loc:SetLocation(context:GetLocation())
        ExitBlock(b)


        ActionContext actContext
        loc = actContext:GetLocation()
        loc:SetLocation(context:GetLocation())
        ExitAction(actContext)
        ExitClass()
    end

    action ExitClass
        if currentClass not= undefined
            CompilerErrorManager manager = GetCompilerErrorManager()
            if manager:IsCompilationErrorFree()
                currentClass:ResolveFrames()
            end
        end
    end

    action ExitFullClassDeclaration(FullClassDeclarationContext context) 
        ExitClass()
    end

    action ExitActionHeader(ActionContext context)
        if currentClass not= undefined
            //get the method name
            List<Variable> list = context:parameters
            Iterator<Variable> paramIt = list:GetIterator()
            text key = currentClass:ResolveActionKey(context:actionName, paramIt,
                GetSymbolTable(), GetCompilerErrorManager())

            Action method = currentClass:GetAction(key)
            currentAction = method
            ActionOpcode actionOpcode
            currentActionOpcode = actionOpcode
            currentActionOpcode:SetAction(method)
            currentActionOpcode:SetClass(currentClass)

            boolean isMain = method:IsMain()
            text null = undefined
            text name = method:GetName()
            text params = method:ConvertActionToBytecodeParameterInterfaceSignature()
            methodWriter = 
                classWriter:VisitMethod(opcodes:GetPublic(), 
                name, params, null, undefined)
            currentActionOpcode:SetMethodWriter(methodWriter)
            currentClassOpcode:Add(currentActionOpcode)
        end
    end

    action EnterConstructor(ConstructorContext context) 
        currentAction = currentClass:GetConstructor()
        isInAction = true

        ActionOpcode actionOpcode
        currentActionOpcode = actionOpcode
        currentActionOpcode:SetAction(currentAction)
        currentActionOpcode:SetClass(currentClass)
        currentActionOpcode:SetMethodWriter(methodWriter)
        currentActionOpcode:SetIsConstructor(true)
        currentClassOpcode:SetConstructor(currentActionOpcode)
    end

    action ExitConstructor(ConstructorContext context) 
        ClearActionState()
        
        if currentActionOpcode not= undefined
            if not poppedBlockOpcodes:IsEmpty()
                currentActionOpcode:Add(poppedBlockOpcodes:Pop())
            end

            //if there are opcodes on the opcode stack for a return, pop them
            //there should never be more than 1, so throw an error if there is
            remaining = opcodeStack:GetSize()
            if remaining not= 0
                if remaining not= 1
                    //alert("Compiler Bug: Cannot have more than 1 remaining opcode on the opcode stack at the end of an action.")
                else 
                    QuorumOpcode op = opcodeStack:Pop()
                    currentActionOpcode:Add(op)
                end
            end
        end
        currentAction = undefined
        currentActionOpcode = undefined
        isInAction = false
    end

    action EnterAction(ActionContext context) 
        SetNormalAction()
        isInAction = true
    end

    action ExitAction(ActionContext context) 
        ClearActionState()
        
        if currentActionOpcode not= undefined
            if not poppedBlockOpcodes:IsEmpty()
                currentActionOpcode:Add(poppedBlockOpcodes:Pop())
            end

            //if there are opcodes on the opcode stack for a return, pop them
            //there should never be more than 1, so throw an error if there is
            remaining = opcodeStack:GetSize()
            if remaining not= 0
                if remaining not= 1
                    //alert("Compiler Bug: Cannot have more than 1 remaining opcode on the opcode stack at the end of an action.")
                else 
                    QuorumOpcode op = opcodeStack:Pop()
                    currentActionOpcode:Add(op)
                end
            end
        end
        isInAction = false
    end

    action ExitAlertStatement(AlertContext context) 
        QuorumOpcode op = opcodeStack:Pop()
        AlertOpcode al
        al:SetOpcode(op)
        al:SetMethodWriter(methodWriter)
        currentBlockOpcode:Add(al)
    end

    action ExitIs(IsContext context) 
        QualifiedName name = context:name
        //now resolve the name from the current class
        key = name:GetStaticKey()
        Type right
        right:SetToObject(key)
        CompilerErrorManager manager = GetCompilerErrorManager()
        errors = manager:GetErrorAmount()
        currentClass:ResolveType(context:GetLocation(), right, GetSymbolTable(), manager)
        //check if there was an error. If so, ignore the rest.
        errors2 = manager:GetErrorAmount()

        if errors = errors2
            //now check to see if it's even possible that this type "is" the other type
            TypeChecker checker = GetTypeChecker()
            Operation operation
            operation:SetOperation(operation:IS)

            QuorumOpcode op = opcodeStack:Pop()
            Type left = op:GetType()
            TypeCheckResult result = checker:Check(left, right, operation)

            if result:errorType = undefined
                IsOpcode opcode = cast(IsOpcode, result:GetQuorumOpcode())
                opcode:SetCastTo(right)
                opcode:SetOpcode(op)
                opcode:SetMethodWriter(methodWriter)
                opcodeStack:Push(opcode)
            else
                IsOpcode isOpcode //empty, but we're throwing an error anyway
                opcodeStack:Push(isOpcode)

                CompilerError error = result:GetCompilerError(context:GetLocation())
                manager:Add(error)
            end
        end
    end

    action ExitOutputStatement(OutputContext context)
        QuorumOpcode op = opcodeStack:Pop()
        OutputOpcode out
        out:SetOpcode(op)
        out:SetMethodWriter(methodWriter)
        currentBlockOpcode:Add(out)
    end

    action ExitSayStatement(SayContext context)
        QuorumOpcode op = opcodeStack:Pop()
        SayOpcode out

        if not outputSpeechCommands
            out:SetOutputSpeech(outputSpeechCommands)
        end

        out:SetOpcode(op)
        out:SetMethodWriter(methodWriter)
        currentBlockOpcode:Add(out)
    end

    action EnterBlock(BlockContext context)
        if currentBlock = undefined
            currentBlock = currentAction:GetBlock()
            blockPositionStack:Push(0)
        else 
            integer value = blockPositionStack:Pop()
            if value < currentBlock:GetSubBlockSize()
                currentBlock = currentBlock:GetBlock(value)
                blockPositionStack:Push(value + 1)
                //now push on a 0 for the new block
                blockPositionStack:Push(0)
            else 
                alert("Compiler Bug in EnterBlock of the Type Check Listener.")
            end
        end

        if currentBlockOpcode = undefined
            BlockOpcode block
            currentBlockOpcode = block
            currentBlocks:Push(block)
        else
            BlockOpcode block
            block:SetParentBlock(currentBlockOpcode)
            currentBlockOpcode = block
            currentBlocks:Push(block)
        end
    end
    
    action ExitBlock(BlockContext context)
        if currentBlock not= undefined
            recentlyPoppedBlock = currentBlock
            currentBlock = currentBlock:GetParentBlock() //may be undefined
            blockPositionStack:Pop()
        end

        if currentBlockOpcode not= undefined
            BlockOpcode op = currentBlocks:Pop()
            poppedBlockOpcodes:Push(op)
            if currentBlocks:IsEmpty()
                currentBlockOpcode = undefined
            else
                currentBlockOpcode = currentBlocks:Peek()
            end
        end
    end

    action EnterLoopStatement(LoopContext context) 
        LoopOpcode loop
        loop:SetLocation(context:GetLocation())
        loop:SetMethodWriter(methodWriter)
        if context:isUntil
            loop:SetUntil()
        elseif context:isTimes
            loop:SetTimes()
        else
            loop:SetWhile()
        end

        if context:isTimes
            constant text LOOP_NAME = "Loopy"
            Variable variable = undefined
            variable = currentBlock:GetVariable(loopCounter + LOOP_NAME)
            loop:SetVariable(variable)
        end

        loopStack:Push(loop)
        loopCounter = loopCounter + 1
    end

    action ExitLoopStatement(LoopContext context) 
        LoopOpcode loop = loopStack:Pop()
        QuorumOpcode qop = opcodeStack:Pop()
        qop:SetIsIfExpression(true)
        
        Type type = qop:GetType()
        if type = undefined
            CompilerError error
            error:SetErrorMessage("I cannot determine the type of the loop expression.")
            error:SetLocation(context:GetLocation())
            CompilerErrorType errorType
            errorType:SetCurrentType(errorType:REPEAT_NON_BOOLEAN)
            error:SetCompilerErrorType(errorType)
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        if loop:IsTimes()
            if not type:IsInteger()
                CompilerError error
                error:SetErrorMessage("Repeat times statements can only accept integers, but the expression's type was " + type:GetStaticKey() + ".")
                error:SetLocation(context:GetLocation())
                CompilerErrorType errorType
                errorType:SetCurrentType(errorType:REPEAT_TIMES_NON_INTEGER)
                error:SetCompilerErrorType(errorType)
                CompilerErrorManager manager = GetCompilerErrorManager()
                manager:Add(error)
                return now
            end
        else
            if not type:IsBoolean()
                CompilerError error
                error:SetErrorMessage("Repeat while and until statements can only accept booleans, but the expression's type was " + type:GetStaticKey() + ".")
                error:SetLocation(context:GetLocation())
                CompilerErrorType errorType
                errorType:SetCurrentType(errorType:REPEAT_NON_BOOLEAN)
                error:SetCompilerErrorType(errorType)
                CompilerErrorManager manager = GetCompilerErrorManager()
                manager:Add(error)
                return now
            end
        end        

        loop:SetExpression(qop)
        BlockOpcode recentlyPopped = poppedBlockOpcodes:Pop()
        loop:SetBlock(recentlyPopped)
        
        currentBlockOpcode:Add(loop)
    end

    action EnterCheckStatement(CheckContext context) 
        CheckDetectOpcode ch
        ch:SetCheckLabelInteger(checkCount)
        ch:SetMethodWriter(methodWriter)
        checkCount = checkCount + 1
        checkStack:Push(ch)
    end
    
    action ExitCheckStatement(CheckContext context) 
        CheckDetectOpcode checkOp = checkStack:Pop()
        BlockOpcode recentlyPopped = poppedBlockOpcodes:Pop()
        checkOp:SetBlock(recentlyPopped)
        currentBlockOpcode:Add(checkOp)
        checkCount = checkCount + 1
    end

    action EnterDetectStatement(DetectStatementContext context) 
    end

    action ExitDetectStatement(DetectStatementContext context) 
        CheckDetectOpcode checkOp = checkStack:Peek()
        DetectBlockOpcode op
        op:SetMethodWriter(methodWriter)
        BlockOpcode recentlyPopped = poppedBlockOpcodes:Pop()
        op:SetBlock(recentlyPopped)

        //get the exception variable from the block
        Variable exceptionVariable = recentlyPoppedBlock:GetExceptionVariable()
        op:SetExceptionVariable(exceptionVariable)
        checkOp:AddDetectBlock(op)
    end

    action EnterAlwaysStatement(AlwaysStatementContext context)
    end

    action ExitAlwaysStatement(AlwaysStatementContext context) 
        CheckDetectOpcode checkOp = checkStack:Peek()

        DetectBlockOpcode op
        op:SetMethodWriter(methodWriter)
        op:SetIsAlways(true)
        BlockOpcode recentlyPopped = poppedBlockOpcodes:Pop()
        Variable exceptionVariable = recentlyPoppedBlock:GetExceptionVariable()
        op:SetExceptionVariable(exceptionVariable)
        op:SetBlock(recentlyPopped)

        checkOp:SetAlwaysBlock(op)
    end

    action EnterIfStatement(IfContext context) 
        ConditionalOpcode conditional
        conditional:SetIfLabelInteger(ifCount)
        conditional:SetMethodWriter(methodWriter)

        ifCount = ifCount + 1
        ifStack:Push(conditional)
    end
    

    action ExitIfStatement(IfContext context) 
        ConditionalOpcode conditional = ifStack:Pop()
        QuorumOpcode qop = opcodeStack:Pop()

        if qop = undefined //there is a problem and we have previously thrown a compiler error
            return now
        end
        Type type = qop:GetType()
        if type = undefined
            CompilerError error
            error:SetErrorMessage("If statements can only accept booleans, but the expression's type is unknown.")
            error:SetLocation(context:GetLocation())
            CompilerErrorType errorType
            errorType:SetCurrentType(errorType:IF_INVALID_EXPRESSION)
            error:SetCompilerErrorType(errorType)
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        elseif not type:IsBoolean()
            CompilerError error
            error:SetErrorMessage("If statements can only accept booleans, but the expression's type was " + type:GetStaticKey() + ".")
            error:SetLocation(context:GetLocation())
            CompilerErrorType errorType
            errorType:SetCurrentType(errorType:IF_INVALID_EXPRESSION)
            error:SetCompilerErrorType(errorType)
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        qop:SetIsIfExpression(true)
        conditional:SetExpression(qop)
        BlockOpcode recentlyPopped = poppedBlockOpcodes:Pop()
        conditional:SetBlock(recentlyPopped)
        
        currentBlockOpcode:Add(conditional)
    end

    action EnterElseIfStatement(IfContext context) end
    action ExitElseIfStatement(IfContext context) 
        ConditionalOpcode conditional = ifStack:Peek()
        QuorumOpcode qop = opcodeStack:Pop()


        Type type = qop:GetType()
        if type = undefined
            CompilerError error
            error:SetErrorMessage("If statements can only accept booleans, but the expression's type is unknown.")
            error:SetLocation(context:GetLocation())
            CompilerErrorType errorType
            errorType:SetCurrentType(errorType:IF_INVALID_EXPRESSION)
            error:SetCompilerErrorType(errorType)
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        elseif not type:IsBoolean()
            CompilerError error
            error:SetErrorMessage("If statements can only accept booleans, but the expression's type was " + type:GetStaticKey() + ".")
            error:SetLocation(context:GetLocation())
            CompilerErrorType errorType
            errorType:SetCurrentType(errorType:IF_INVALID_EXPRESSION)
            error:SetCompilerErrorType(errorType)
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end



        qop:SetIsIfExpression(true)
        BlockOpcode recentlyPopped = poppedBlockOpcodes:Pop()
        conditional:AddElseIf(qop, recentlyPopped)
    end

    action EnterElseStatement(IfContext context) end
    action ExitElseStatement(IfContext context) 
        ConditionalOpcode conditional = ifStack:Peek()
        BlockOpcode recentlyPopped = poppedBlockOpcodes:Pop()
        conditional:SetElseBlock(recentlyPopped)
    end

    


    action ExitObjectAssignment(ObjectAssignmentContext context) 
        text name = context:name
        text object = context:object
        QualifiedName theParent = context:parentName
        
        Variable variable = undefined
        Variable field = undefined
        Class clazz = undefined
        Class fieldHolder = undefined
        if not isInAction
            variable = currentClass:GetVariable(object)
        else 
            variable = currentBlock:GetVariable(object)
        end

        
        //this is not a call to a parent field.
        if theParent not= undefined
            //now get the field from that object

        else
            if variable not= undefined //if it is, it should have been caught in a previous phase
                Type type = variable:GetType()
                if not type:IsPrimitive() //if it is, again previous phase
                    text staticKey = type:GetStaticKey()
                    SymbolTable table = GetSymbolTable()
                    clazz = table:GetClass(staticKey)
                    fieldHolder = clazz

                    //get a field. It has to be there, otherwise a previous phase would have complained
                    field = clazz:GetVariable(name)
                else  
                    CompilerError error
                    error:SetLocation(variable)
                    CompilerErrorType errorType
                    errorType:SetCurrentType(errorType:INVALID_OPERATOR)
                    error:SetCompilerErrorType(errorType)
                    error:SetErrorMessage("I cannot assign a value to a variable " +
                        "named " + variable:GetName() + " because it is of type " + type:GetStaticKey() + ", which is a primitive")
                    CompilerErrorManager manager = GetCompilerErrorManager()
                    manager:Add(error)
                end
            end

        end

        right = opcodeStack:Pop()


        Operation assign
        assign:SetOperation(assign:EQUALS)

        TypeChecker checker = GetTypeChecker()
        TypeCheckResult result = checker:Check(field:GetType(), right:GetType(), undefined, true) 

        integer location = variable:GetBytecodeLocation()
        Type value = result:result
        QuorumOpcode qop = result:GetQuorumOpcode()
        AssignmentOpcode assignment = cast(AssignmentOpcode, result:GetQuorumOpcode())
        assignment:SetLocation(context:GetLocation())
        assignment:SetClass(currentClass)
        assignment:SetRightHandSide(right)
        assignment:SetFieldHolder(fieldHolder)
        assignment:SetType(value)
        assignment:SetMethodWriter(methodWriter)
        assignment:SetVariable(variable)
        assignment:SetField(field)
        assignment:SetIsObjectField(true)

        if isInAction
            currentBlockOpcode:Add(assignment)
        else //add the opcode to the field calculator
            currentClassOpcode:AddField(assignment)
        end
    end

    action ExitParentAssignment(ParentAssignmentContext context) 
        text variableName = context:name
        QualifiedName parentName = context:parentName

        SymbolTable table = GetSymbolTable()
        CompilerErrorManager manager = GetCompilerErrorManager()
        TypeChecker checker = GetTypeChecker()

        Type resolvedType
        resolvedType:SetToObject(parentName:GetStaticKey())
        currentClass:ResolveType(context:GetLocation(), resolvedType, table, manager)
        
        hasParent = currentClass:HasParentClass(resolvedType:GetStaticKey())
        if not hasParent
            CompilerError error
            error:SetLocation(context:GetLocation())
            CompilerErrorType t
            t:SetCurrentType(t:MISSING_PARENT)
            error:SetCompilerErrorType(t)
            text message = "I could not locate a parent class named " + resolvedType:GetStaticKey() + "."
            error:SetErrorMessage(message)
            manager:Add(error)
            return now
        end
        Class parentClass = currentClass:GetParentClass(resolvedType:GetStaticKey())
        Variable var = parentClass:GetVariable(variableName)
        if var = undefined
            CompilerError error
            error:SetLocation(context:GetLocation())
            CompilerErrorType t
            t:SetCurrentType(t:MISSING_VARIABLE)
            error:SetCompilerErrorType(t)
            text message = "I could not locate a variable named " + variableName + " in class " + parentClass:GetStaticKey()
            error:SetErrorMessage(message)
            manager:Add(error)
            return now
        end

        Type left = var:GetType()
        
        right = opcodeStack:Pop()
        Operation assign
        assign:SetOperation(assign:EQUALS)

        if right = undefined //the system should have already output an error, so return
            return now
        end

        TypeCheckResult result = checker:Check(left, right:GetType(), undefined, true) 
        CompilerError error = result:GetCompilerError(context:GetLocation())

        if error not= undefined
            manager:Add(error)
            return now
        end

        Type value = result:result
        QuorumOpcode qop = result:GetQuorumOpcode()
        AssignmentOpcode assignment = cast(AssignmentOpcode, result:GetQuorumOpcode())
        assignment:SetLocation(context:GetLocation())
        assignment:SetClass(currentClass)
        assignment:SetRightHandSide(right)
        assignment:SetType(value)
        assignment:SetMethodWriter(methodWriter)
        assignment:SetVariable(var)
        assignment:SetParentWithField(parentClass)

        if isInAction
            currentBlockOpcode:Add(assignment)
        else //add the opcode to the field calculator
            currentClassOpcode:AddField(assignment)
        end
    end

    action ExitNormalAssignment(NormalAssignmentContext context) 
        text name = context:name
        Variable variable = undefined
        if not isInAction
            variable = currentClass:GetVariable(name)
        else 
            variable = currentBlock:GetVariable(name)
        end

        if variable = undefined
            CompilerError error
            error:SetLocation(context:GetLocation())
            CompilerErrorType t
            t:SetCurrentType(t:MISSING_VARIABLE)
            error:SetCompilerErrorType(t)
            text message = "I could not locate the variable " + name
            error:SetErrorMessage(message)
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        Type left = variable:GetType()
        QuorumOpcode right = undefined
        if context:hasRightHandSide = false
            Type typeOriginal = context:leftHandSide
            if typeOriginal:IsPrimitive()
                //Note: We need to investigate/run a study on whether this decision
                //matters or not. 

                CompilerError error
                error:SetLocation(context:GetLocation())
                CompilerErrorType t
                t:SetCurrentType(t:NO_RIGHT_HAND_SIDE_ON_NORMAL_ASSIGNMENT)
                error:SetCompilerErrorType(t)
                text message = "I noticed that the variable " + variable:GetName()
                    + " has the declared type of " + left:GetStaticKey() 
                    + ", but the right hand side of the statement was blank." 
                if left:IsInteger()
                    message = message + " For example, you might try integer " + variable:GetName()
                        + " = 0"
                elseif left:IsBoolean()
                    message = message + " For example, you might try boolean " + variable:GetName()
                        + " = true"
                elseif left:IsNumber()
                    message = message + " For example, you might try number " + variable:GetName()
                        + " = 0.0"
                elseif left:IsText()
                    message = message + " For example, you might try text " + variable:GetName()
                        + " = " + message:GetDoubleQuote() + message:GetDoubleQuote()
                end

                error:SetErrorMessage(message)
                CompilerErrorManager manager = GetCompilerErrorManager()
                manager:Add(error)
//                Type type = typeOriginal:Copy()
//                type:SetIsConstant(true)
//                QuorumConstant const
//                const:SetMethodWriter(methodWriter)
//                const:SetType(type)
//                if type:IsInteger()
//                    type:SetIntegerConstant(0)
//                    const:integerValue = 0
//                elseif type:IsBoolean()
//                    type:SetBooleanConstant(false)
//                    const:booleanValue = false
//                elseif type:IsNumber()
//                    type:SetNumberConstant(0.0)
//                    const:numberValue = 0.0
//                elseif type:IsText()
//                    type:SetTextConstant("")
//                    const:textValue = ""
//                end
//                opcodeStack:Push(const)
            else 
                SymbolTable table = me:GetSymbolTable()
                Class clazz = table:GetClass(left:GetStaticKey())
                CreateObjectOpcode opcode
                opcode:SetLocation(context:GetLocation())
                opcode:SetMethodWriter(methodWriter)
                opcode:SetClass(clazz)
                opcode:SetVariable(variable)

                if isInAction
                    currentBlockOpcode:Add(opcode)
                    return now
                else //add the opcode to the field calculator
                    currentClassOpcode:AddField(opcode)
                    return now
                end
                
            end
        end

        right = opcodeStack:Pop()


        Operation assign
        assign:SetOperation(assign:EQUALS)

        TypeChecker checker = GetTypeChecker()

        if right = undefined //the system should have already output an error, so return
            return now
        end

        TypeCheckResult result = checker:Check(left, right:GetType(), undefined, true) 
        CompilerError error = result:GetCompilerError(context:GetLocation())

        if error not= undefined
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        integer location = variable:GetBytecodeLocation()
        Type value = result:result
        QuorumOpcode qop = result:GetQuorumOpcode()
        AssignmentOpcode assignment = cast(AssignmentOpcode, result:GetQuorumOpcode())
        assignment:SetLocation(context:GetLocation())
        assignment:SetClass(currentClass)
        assignment:SetRightHandSide(right)
        assignment:SetType(value)
        assignment:SetMethodWriter(methodWriter)
        //assignment:SetBytecodeLocation(location)
        assignment:SetVariable(variable)

        if isInAction
            currentBlockOpcode:Add(assignment)
        else //add the opcode to the field calculator
            currentClassOpcode:AddField(assignment)
        end
    end

    action EnterNoTypeAssignment(NoTypeAssignmentContext context) 
        a = 5
    end
    action ExitNoTypeAssignment(NoTypeAssignmentContext context) 
        text name = context:name
        Variable variable = undefined
        TypeChecker checker = GetTypeChecker()

        if context:hasMe or context:isField or not isInAction
            variable = currentClass:GetVariable(name)
        else 
            variable = currentBlock:GetVariable(name)
        end

        Type left = variable:GetType()

        QuorumOpcode right = opcodeStack:Pop()
        if left = undefined //if the type is undefined, it might be possible to infer it
            InferenceResult infer = checker:CanInfer(right)
            if infer:canInfer //hey awesome, that was easy!
                Type rightType = right:GetType()
                rightType = rightType:Copy()
                left = rightType
                variable:SetType(left)
            else
                CompilerError error
                error:SetLocation(variable)
                CompilerErrorType errorType
                errorType:SetCurrentType(errorType:VARIABLE_INFERENCE)
                error:SetCompilerErrorType(errorType)
                if right not= undefined
                    Type otherType = right:GetType()
                    if otherType not= undefined
                        error:SetErrorMessage("I will not infer the type of the " + 
                            "right hand side of this expression automatically. To " +
                            " fix this, change the declaration to " + otherType:GetStaticKeyWithGenerics() + 
                            " " + variable:GetName() + ".")
                    else 
                        error:SetErrorMessage("I cannot infer the type of the " + 
                            "right hand side of this expression assigning to the " +
                            " variable " + variable:GetName() + ".")
                    end

                else
                    error:SetErrorMessage("I will not infer the type of the " + 
                        "right hand side of this expression automatically, as the right hand side of this expression's type is undefined.")
                end

                CompilerErrorManager manager = GetCompilerErrorManager()
                manager:Add(error)
                return now
            end
        end

        Operation assign
        assign:SetOperation(assign:EQUALS)

        TypeCheckResult result = checker:Check(left, right:GetType(), undefined, true) 

        if result:errorType = undefined
            integer location = variable:GetBytecodeLocation()
            Type value = result:result
            AssignmentOpcode assignment = cast(AssignmentOpcode, result:GetQuorumOpcode())
            assignment:SetLocation(context:GetLocation())
            assignment:SetClass(currentClass)
            assignment:SetRightHandSide(right)
            assignment:SetType(value)
            assignment:SetMethodWriter(methodWriter)
            assignment:SetVariable(variable)
            if not isInAction
                currentClassOpcode:AddField(assignment)
            else
                currentBlockOpcode:Add(assignment)
            end
        else 
            CompilerError error = result:GetCompilerError(context:GetLocation())
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end
    end
    
    action EnterVariableSoloFunctionCall(VariableFunctionCallContext context) 
        isNextVariableReferenceMe = context:hasMe
        Array<ActionCallOpcode> stack
        actionCallStacks:Add(me:currentActionStack, stack)
        currentActionStack = currentActionStack + 1


        ActionCallOpcode actionCall
        actionCall:SetLocation(context:GetLocation())
        actionCall:SetMethodWriter(methodWriter)
        actionCall:SetIsActionCall(true)
        stack:Add(actionCall)
    end

    private action ComputeInitialParameters(integer size, ActionCallOpcode actionCall)
        Array<QuorumOpcode> parametersBackward
        repeat size times
            QuorumOpcode param = opcodeStack:Pop()
            parametersBackward:Add(param)
        end

        Array<Type> parameters
        Array<QuorumOpcode> parameterOpcodes
        i = size - 1
        repeat size times
            QuorumOpcode op = parametersBackward:Get(i)
            parameters:Add(op:GetType())
            parameterOpcodes:Add(op)
            i = i - 1
        end

        actionCall:SetParameters(parameterOpcodes)
        actionCall:SetParameterTypes(parameters)
    end

    action ExitVariableSoloFunctionCall(VariableFunctionCallContext context)
        Array<ActionCallOpcode> actionArray = actionCallStacks:GetValue(0)
        ActionCallOpcode actionCall = actionArray:Get(0)
        actionCall:SetPushOnMe(true)
        ActionExpressionListContext params =  actionCallParameterStack:Pop()
        size = params:size

        ComputeInitialParameters(size, actionCall)

        //check if this is an object call
        text object = context:objectName
        Variable variable = undefined
        boolean isObjectCall = false
        if object not= "" //this is a call to a field.
            if isInAction 
                variable = currentBlock:GetVariable(object)
            else //must be a field
                variable = currentClass:GetVariable(object)
            end
            isObjectCall = true
        end

        SymbolTable table = GetSymbolTable()
        Type fieldType = undefined
        Class fieldClass = undefined
        if isObjectCall = true and variable = undefined
            CompilerError classNotFoundError
            classNotFoundError:SetLocation(context:GetLocation())
            classNotFoundError:SetErrorMessage("I could not locate the variable " + object + ". Is it correctly?")
            CompilerErrorType errorType
            errorType:SetCurrentType(errorType:MISSING_VARIABLE)
            classNotFoundError:SetCompilerErrorType(errorType)
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(classNotFoundError)
            return now
        elseif isObjectCall = true and variable not= undefined
            fieldType = variable:GetType()
            fieldClass= table:GetClass(fieldType:ConvertToNonPrimitiveStaticKey())
            
            if fieldClass = undefined
                CompilerError classNotFoundError
                classNotFoundError:SetLocation(context:GetLocation())
                classNotFoundError:SetErrorMessage("I could not locate the Class " + fieldType:GetStaticKey() + ".")
                CompilerErrorType errorType
                errorType:SetCurrentType(errorType:MISSING_CLASS)
                classNotFoundError:SetCompilerErrorType(errorType)
                CompilerErrorManager manager = GetCompilerErrorManager()
                manager:Add(classNotFoundError)
                return now
            end

        end

        Class testMe = undefined

        ActionCall call
        call:SetLocation(context:GetLocation())
        if isObjectCall
            testMe = fieldClass
        else
            testMe = currentClass
        end
        
        call:actualParameters = actionCall:GetParameterTypes()
        call:name = context:name
        call:checker = GetTypeChecker()
        call:table = table

        ActionCallResolution resolved = ResolveActionCall(testMe, isObjectCall, fieldClass, variable, call, actionCall)
        resolved:location = context:GetLocation()

        isNextVariableReferenceMe = false
        Array<ActionCallOpcode> stack = actionCallStacks:RemoveKey(me:currentActionStack - 1)
        currentActionStack = currentActionStack - 1

        ChainedActionCallOpcode ops
        ops:SetMethodWriter(methodWriter)
        ops:SetLocation(context:GetLocation())
        ops:SetIsSoloCall(true)
        Iterator<ActionCallOpcode> it = stack:GetIterator()
        repeat while it:HasNext()
            ActionCallOpcode op = it:Next()
            ops:Add(op)
        end

        //since this is a solo call, there is no assignment statement.
        //thus, if there's a return type, we need to pop it off the stack.
        ActionCallOpcode op = stack:GetFromEnd()
        Type returnType = op:GetType()
        if returnType not= undefined
            if not returnType:IsVoid()
                ops:SetPopReturn(true)
            end
        end
        currentBlockOpcode:Add(ops)
    end

    private action ResolveActionCall(Class testMe, boolean isObjectCall, 
        Class fieldClass, Variable variable, ActionCall call, ActionCallOpcode actionCall) returns ActionCallResolution
        call:variable = variable
        ActionCallResolution resolved = testMe:ResolveAction(call)

        if isObjectCall
            resolved:classToMakeCallOn = fieldClass
            resolved:callingClass = currentClass
            actionCall:SetFieldHolder(currentClass)
            actionCall:SetPushOnMe(false)
            actionCall:SetField(variable)
            actionCall:SetIsSoloObjectCall(true)
            resolved:typeToMakeCallOn = variable:GetType()
        else
            resolved:classToMakeCallOn = currentClass
        end

        
        FinishActionResolution(actionCall, resolved)
        return resolved
    end

    action FinishActionResolution(ActionCallOpcode actionCall, ActionCallResolution resolved)
        if resolved not= undefined and resolved:isResolved
            actionCall:SetActionCallResolution(resolved)
            actionCall:SetIsActionCall(true)
            actionCall:SetCallingClass(currentClass)
            actionCall:SetActionCallResolution(resolved)

            Action act = resolved:resolvedAction
            
            actionCall:SetParameters(ComputeFinalParameters(actionCall:GetParameters(), resolved:converter))

            //check to see if the return type needs to be auto-boxed back
            //into another type.

//            if currentClass:GetStaticKey() = "Main"
//                a = 5
//            end
            
            Type returnType = act:GetReturnType()
            if not actionCall:GetPushOnMe() //if it's a me call, it doesn't matter
                if returnType:IsMappedToGeneric() //it is mapped to a generic, so find the variable it is mapped to
                    Type t = resolved:typeToMakeCallOn
                    Class c = resolved:classToMakeCallOn

                    integer index = -1
                    Class parentClass = act:GetParentClass()
                    if parentClass:GetStaticKey() = c:GetStaticKey()
                        index = c:GetIndexOfGeneric(returnType:GetMappedGeneric())
                    else //this action must be defined in a parent. Map its generics separately
                        index = parentClass:GetIndexOfGeneric(returnType:GetMappedGeneric())
                        index = c:MapParentGenericToMe(parentClass:GetStaticKey(), index)
                    end

                    if index not= -1
                        Type left = t:GetGeneric(index)
                        TypeChecker checker = GetTypeChecker()
                        
                        //get the type of the thing. If it is a primitive
                        //it is stored type erased, but might look like a
                        //primitive, so get the object version
                        Type right
                        text boxedKey = left:ConvertToNonPrimitiveStaticKey()
                        right:SetToObject(boxedKey)

                        //since we know this is defined as a generic,
                        //it is equivalent to a cast
                        Operation op
                        op:SetOperation(op:CAST)
                        TypeCheckResult result = checker:Check(left, returnType, op, false)
                        if result:errorType = undefined
                            QuorumOpcode opcode = result:GetQuorumOpcode()
                            if opcode not= undefined
                                opcode:SetMethodWriter(methodWriter)
                                //this may be null or ignored
                                actionCall:SetAutoBoxOpcode(opcode)
                                actionCall:SetType(left)
                            end
                        else
                            CompilerErrorManager manager = GetCompilerErrorManager()
                            manager:Add(result:GetCompilerError(resolved:location))
                        end

                        a = 5
                    else //this generic doesn't exist, throw an error
//                        CompilerError error
//                        error:SetLocation(resolved:location)
//                        error:SetErrorMessage("I found a return with the value " + t:GetStaticKey() + 
//                            ", but could find no definition for " + " the generic " +
//                            "in the class " + c:GetStaticKey())
//                        CompilerErrorType errorType
//                        errorType:SetCurrentType(errorType:MISSING_CLASS)
//                        error:SetCompilerErrorType(errorType)
//                        CompilerErrorManager manager = GetCompilerErrorManager()
//                        manager:Add(error)
//                        return now
                    end

                    a = 5
                end
            end

            
        else
            CompilerError error = resolved:error 
            if error not= undefined
                CompilerErrorManager manager = GetCompilerErrorManager()
                manager:Add(error)
            end
        end
    end

    

    action EnterVariableFunctionCall(VariableFunctionCallContext context) 
        isNextVariableReferenceMe = context:hasMe
        Array<ActionCallOpcode> stack
        actionCallStacks:Add(me:currentActionStack, stack)
        currentActionStack = currentActionStack + 1
    end

    action ExitVariableFunctionCall(VariableFunctionCallContext context) 
        isNextVariableReferenceMe = false
        Array<ActionCallOpcode> stack = actionCallStacks:RemoveKey(me:currentActionStack - 1)
        currentActionStack = currentActionStack - 1

        ChainedActionCallOpcode ops
        ops:SetLocation(context:GetLocation())
        Iterator<ActionCallOpcode> it = stack:GetIterator()
        repeat while it:HasNext()
            ActionCallOpcode op = it:Next()
            ops:Add(op)
        end

        opcodeStack:Push(ops)
    end

    action EnterParentVariableSoloFunctionCall(ParentVariableFunctionCallContext context) 
        isNextVariableReferenceMe = context:hasMe
        Array<ActionCallOpcode> stack
        actionCallStacks:Add(me:currentActionStack, stack)
        currentActionStack = currentActionStack + 1

        parentCallStack:Push(context)
    end

    action ExitParentVariableSoloFunctionCall(ParentVariableFunctionCallContext context) 
        Array<ActionCallOpcode> stack = actionCallStacks:RemoveKey(me:currentActionStack - 1)
        currentActionStack = currentActionStack - 1

        ChainedActionCallOpcode ops
        ops:SetMethodWriter(methodWriter)
        ops:SetLocation(context:GetLocation())
        Iterator<ActionCallOpcode> it = stack:GetIterator()
        repeat while it:HasNext()
            ActionCallOpcode op = it:Next()
            ops:Add(op)
        end

        //since this is a solo call, there is no assignment statement.
        //thus, if there's a return type, we need to pop it off the stack.
        ActionCallOpcode op = stack:GetFromEnd()
        Type returnType = op:GetType()
        if returnType not= undefined
            if not returnType:IsVoid()
                ops:SetPopReturn(true)
            end
        end
        currentBlockOpcode:Add(ops)
    end

    action EnterParentVariableFunctionCall(ParentVariableFunctionCallContext context)
        isNextVariableReferenceMe = context:hasMe
        Array<ActionCallOpcode> stack
        actionCallStacks:Add(me:currentActionStack, stack)
        currentActionStack = currentActionStack + 1

        parentCallStack:Push(context)
    end

    private action AdaptToParentActionCall(ParentVariableFunctionCallContext context, ActionCallOpcode actionCall) returns ActionCallOpcode
        //actionCall:SetMethodWriter(methodWriter)
        actionCall:SetIsParentCall(true)

        boolean hasMe = context:hasMe
        text variableName = context:variableName
        QualifiedName parentName = context:parentName
        
        Variable variable = undefined
        TypeChecker checker = GetTypeChecker()
        CompilerErrorManager manager = GetCompilerErrorManager()
        SymbolTable table = GetSymbolTable()

        boolean skipFieldVariable = variableName = undefined

        if not skipFieldVariable
            skipFieldVariable = variableName:IsEmpty()
        end

        if not skipFieldVariable //this parent call has a field variable
            if hasMe or not isInAction
                variable = currentClass:GetVariable(variableName)
            else 
                variable = currentBlock:GetVariable(variableName)
            end

            if variable = undefined
                CompilerError error
                error:SetLocation(context:GetLocation())
                CompilerErrorType t
                t:SetCurrentType(t:MISSING_VARIABLE)
                error:SetCompilerErrorType(t)
                text message = "I could not locate the variable " + variableName + "."
                error:SetErrorMessage(message)
                manager:Add(error)
                return undefined
            end

            Type resolvedType
            resolvedType:SetToObject(parentName:GetStaticKey())
            currentClass:ResolveType(context:GetLocation(), resolvedType, GetSymbolTable(), GetCompilerErrorManager())

            Type variableType = variable:GetType()
            key = variableType:GetStaticKey()

            actionCall:SetVariableToMakeParentCallOn(variable)


            //this can't be null, because resolution happened already. If it is
            //it's a compiler bug, not a user error.
            Class fieldClass = table:GetClass(key)

            hasParent = fieldClass:HasParentClass(resolvedType:GetStaticKey())
            if not hasParent
                CompilerError error
                error:SetLocation(context:GetLocation())
                CompilerErrorType t
                t:SetCurrentType(t:MISSING_PARENT)
                error:SetCompilerErrorType(t)
                text message = "I could not locate a parent class named " + resolvedType:GetStaticKey() + "."
                error:SetErrorMessage(message)
                manager:Add(error)
                return undefined
            end
            actionCall:SetClassToMakeParentCallOn(fieldClass)
            Class parentClass = fieldClass:GetParentClass(resolvedType:GetStaticKey())
            actionCall:SetParentToCallOn(parentClass)
            Type type
            type:SetToObject(parentClass:GetStaticKey())
            actionCall:SetType(type)
            actionCall:SetCallingClass(currentClass)

            return actionCall
        else //this parent call does not have a field variable

            

            Type resolvedType
            resolvedType:SetToObject(parentName:GetStaticKey())
            currentClass:ResolveType(context:GetLocation(), resolvedType, GetSymbolTable(), GetCompilerErrorManager())

            Class parentClass = currentClass:GetParentClass(resolvedType:GetStaticKey())
            hasParent = currentClass:HasParentClass(resolvedType:GetStaticKey())
            if not hasParent
                CompilerError error
                error:SetLocation(context:GetLocation())
                CompilerErrorType t
                t:SetCurrentType(t:MISSING_PARENT)
                error:SetCompilerErrorType(t)
                text message = "I could not locate a parent class named " + resolvedType:GetStaticKey() + "."
                error:SetErrorMessage(message)
                manager:Add(error)
                return undefined
            end

            actionCall:SetParentToCallOn(parentClass)
            return actionCall

        end
        
        
    end


    action ExitParentVariableFunctionCall(ParentVariableFunctionCallContext context)
        Array<ActionCallOpcode> stack = actionCallStacks:RemoveKey(me:currentActionStack - 1)
        currentActionStack = currentActionStack - 1

        ChainedActionCallOpcode ops
        ops:SetLocation(context:GetLocation())
        Iterator<ActionCallOpcode> it = stack:GetIterator()
        repeat while it:HasNext()
            ActionCallOpcode op = it:Next()
            ops:Add(op)
        end

        opcodeStack:Push(ops)
    end

    action ExitActionExpressionList(ActionExpressionListContext context) 
        actionCallParameterStack:Push(context)
    end

    private action ComputeFinalParameters(Array<QuorumOpcode> parameterOpcodes, 
        Array<QuorumOpcode> conversions) returns Array<QuorumOpcode>
        //handle any casts, if there are any
        Array<QuorumOpcode> finalResolvedParameters
        integer next = 0
        repeat parameterOpcodes:GetSize() times
            QuorumOpcode previous = parameterOpcodes:Get(next)
            QuorumOpcode possibleCast = conversions:Get(next)
            if possibleCast not= undefined
                ExplicitCastOpcode caster = cast(ExplicitCastOpcode, possibleCast)
                caster:SetMethodWriter(methodWriter)
                caster:SetOpcodeToCast(previous)
                finalResolvedParameters:Add(caster)
            else //nothing to do with this opcode, just push it
                finalResolvedParameters:Add(previous)
            end
            next = next + 1
        end
        return finalResolvedParameters
    end

    action ExitActionCall(ActionCallContext context)
        ActionCallOpcode actionCall
        actionCall:SetLocation(context:GetLocation())
        actionCall:SetMethodWriter(methodWriter)

        if not parentCallStack:IsEmpty()
            ParentVariableFunctionCallContext parentContext = parentCallStack:Pop()
            AdaptToParentActionCall(parentContext, actionCall)
        end

        SymbolTable table = GetSymbolTable()

        if context:isActionCall //push the "this" pointer
            actionCall:SetIsActionCall(true)
            ActionExpressionListContext params =  actionCallParameterStack:Pop()
            size = params:size

            Class classToMakeCallOn = undefined
            boolean isPrimitive = false
            Array<ActionCallOpcode> stack = actionCallStacks:GetValue(currentActionStack - 1)

            Type calledType = undefined
            if stack:IsEmpty() //this is a solo call, push on this
                actionCall:SetPushOnMe(true)
                classToMakeCallOn = currentClass
            else //else we're making a call on a field, so get it off the stack and take a look
                ActionCallOpcode op = stack:GetFromEnd()
                Type t = op:GetType()
                calledType = t
                if t:IsPrimitive()
                    isPrimitive = true
                end

                text resolvedKey = t:ConvertToNonPrimitiveStaticKey()
                classToMakeCallOn = table:GetClass(resolvedKey)

                //I don't know why, but this fixes a Quorum 2 bug. 
                integer a = 4
                if classToMakeCallOn = undefined
                    CompilerError classNotFoundError
                    classNotFoundError:SetLocation(context:GetLocation())
                    classNotFoundError:SetErrorMessage("I could not locate the class named " + resolvedKey)
                    CompilerErrorType errorType
                    errorType:SetCurrentType(errorType:MISSING_CLASS)
                    classNotFoundError:SetCompilerErrorType(errorType)
                    CompilerErrorManager manager = GetCompilerErrorManager()
                    manager:Add(classNotFoundError)
                    return now
                end
            end

            ComputeInitialParameters(size, actionCall)
            ActionCall call
            call:SetLocation(context:GetLocation())
            call:actualParameters = actionCall:GetParameterTypes()
            call:name = context:name
            call:checker = GetTypeChecker()
            call:table = GetSymbolTable()

            ActionCallResolution resolved = classToMakeCallOn:ResolveAction(call)

            if not resolved:isResolved
                CompilerErrorManager manager = GetCompilerErrorManager()
                manager:Add(resolved:error)
                return now
            end

            if isPrimitive //make sure the call is allowed and inform the writer
                Action act = resolved:resolvedAction
                if act = undefined
                    a = 5
                end
                
                text name = act:GetName()
                if name = "SetValue" or name = "SetValueNative" or name = "GetValue" or name = "GetValueNative"//these calls aren't allowed on primitives
                    CompilerError error
                    error:SetLocation(context:GetLocation())
                    error:SetErrorMessage("I found a call to the primitive calling the action " + name + ", but this cannot be called on a primitive.")
                    CompilerErrorType errorType
                    errorType:SetCurrentType(errorType:PRIMITIVE_INVALID_ACTION_CALL)
                    error:SetCompilerErrorType(errorType)
                    CompilerErrorManager manager = GetCompilerErrorManager()
                    manager:Add(error)
                    return now
                else
                    resolved:isCallOnPrimitive = true
                end
            end
            resolved:typeToMakeCallOn = calledType
            resolved:classToMakeCallOn = classToMakeCallOn
            resolved:callingClass = currentClass
            resolved:location = context:GetLocation()
            FinishActionResolution(actionCall, resolved)
        else //push the variable
            actionCall:SetIsActionCall(false)
            name = context:name
            Variable variable = undefined

            Array<ActionCallOpcode> stack = actionCallStacks:GetValue(currentActionStack - 1)

            if stack:IsEmpty() //This is the first call, so push on the me pointer
                if isNextVariableReferenceMe or not isInAction
                    variable = currentClass:GetVariable(name)
                elseif actionCall:IsParentCall()
                    Class parentClass = actionCall:GetParentToCallOn()

                    if parentClass not= undefined //it's not in the current class
                        variable = parentClass:GetVariable(name)
                    else
                        variable = currentClass:GetVariable(name)
                    end

                    isNextVariableReferenceMe = false
                else 
                    variable = currentBlock:GetVariable(name)
                    isNextVariableReferenceMe = false
                end

                if variable not= undefined
                    Type type = variable:GetType()
                    //if this is null, a variable was used before it was assigned
                    //a type, and thus cannot be infered
                    if type = undefined
                        CompilerError error
                        error:SetLocation(context:GetLocation())
                        error:SetErrorMessage("I found the variable " + name + ", but it cannot be used before it is defined.")
                        CompilerErrorType errorType
                        errorType:SetCurrentType(errorType:MISSING_CLASS)
                        error:SetCompilerErrorType(errorType)
                        CompilerErrorManager manager = GetCompilerErrorManager()
                        manager:Add(error)
                        return now
                    end


                    actionCall:SetPushOnMe(true)
                    actionCall:SetCallerType(type)
                    actionCall:SetType(type)
                    actionCall:SetField(variable)
                    actionCall:SetFieldHolder(currentClass)
                    actionCall:SetCallingClass(currentClass)
                else
                    CompilerError error
                    error:SetLocation(context:GetLocation())
                    error:SetErrorMessage("I could not locate the variable named " + name)
                    CompilerErrorType errorType
                    errorType:SetCurrentType(errorType:MISSING_CLASS)
                    error:SetCompilerErrorType(errorType)
                    CompilerErrorManager manager = GetCompilerErrorManager()
                    manager:Add(error)
                    return now
                end
            else //get the most recent type off the stack
                ActionCallOpcode code = stack:Get(stack:GetSize() - 1)
                
                Type type = code:GetType()
                if not type:IsPrimitive() //if it is, again previous phase will catch this
                    text staticKey = type:GetStaticKey()
                    clazz = table:GetClass(staticKey)
                    
                    //get a field.
                    field = clazz:GetVariable(name)
                    if field not= undefined
                        Type fieldType = field:GetType()
                        actionCall:SetCallerType(fieldType)
                        actionCall:SetType(fieldType)
                        actionCall:SetIsField(true)
                        actionCall:SetField(field)
                        actionCall:SetFieldHolder(clazz)
                        actionCall:SetCallingClass(currentClass)
                        actionCall:SetChainedCall(true)
                    else
                        CompilerError error
                        error:SetLocation(context:GetLocation())
                        error:SetErrorMessage("I could not locate the variable named " + name)
                        CompilerErrorType errorType
                        errorType:SetCurrentType(errorType:MISSING_CLASS)
                        error:SetCompilerErrorType(errorType)
                        CompilerErrorManager manager = GetCompilerErrorManager()
                        manager:Add(error)
                        return now
                    end
                end
            end
        end

        Array<ActionCallOpcode> stack = actionCallStacks:GetValue(currentActionStack - 1)
        stack:Add(actionCall)
    end

    action ExitReturnStatement(ReturnContext context) 
        Type type = currentAction:GetReturnType()
        if not type:IsVoid() //if this is not a void method, handle the return
            QuorumOpcode right = opcodeStack:Pop()

            Operation returnOp
            returnOp:SetOperation(returnOp:RETURN)

            TypeChecker checker = GetTypeChecker()
            TypeCheckResult result = checker:Check(type, right:GetType(), returnOp) 
            CompilerError error = result:GetCompilerError(context:GetLocation())
            if error not= undefined
                CompilerErrorManager manager = GetCompilerErrorManager()
                manager:Add(error)
                return now
            end

            ReturnOpcode opcode = cast(ReturnOpcode, result:GetQuorumOpcode())
            opcode:SetLocation(context:GetLocation())
            opcode:SetReturnValue(right)
            opcode:SetMethodWriter(methodWriter)
            currentBlockOpcode:Add(opcode)
        else //if it is a void method, just do a normal return, but don't pop off the opcode stack
            ReturnOpcode opcode
            opcode:SetLocation(context:GetLocation())
            opcode:SetType(type)
            opcode:SetMethodWriter(methodWriter)
            currentBlockOpcode:Add(opcode)
        end
    end

    action ExitCast(CastContext context) 
        TypeChecker checker = GetTypeChecker()
        QuorumOpcode right = opcodeStack:Peek()
        Operation op
        op:SetOperation(op:CAST)

        Type left = context:type //this has to be resolved
        currentClass:ResolveType(context:GetLocation(), left, GetSymbolTable(), GetCompilerErrorManager())


        TypeCheckResult result = checker:Check(left, right:GetType(), op)
        CompilerError error = result:GetCompilerError(context:GetLocation())
        if error not= undefined
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        ExplicitCastOpcode theCast = cast(ExplicitCastOpcode, result:GetQuorumOpcode())
        if theCast not= undefined
            theCast:SetLocation(context:GetLocation())
            theCast:SetMethodWriter(methodWriter)
            theCast:SetType(result:result)
            theCast:SetOpcodeToCast(opcodeStack:Pop())
            opcodeStack:Push(theCast)
        end
    end


    

    action ExitInequality(InequalityContext context) 
        TypeChecker checker = GetTypeChecker()
        QuorumOpcode right = opcodeStack:Pop()
        QuorumOpcode left = opcodeStack:Pop()
        Operation add
        if context:isGreater
            add:SetOperation(add:GREATER)
        elseif context:isGreaterEquals
            add:SetOperation(add:GREATER_EQUALS)
        elseif context:isLess
            add:SetOperation(add:LESS)
        elseif context:isLessEquals
            add:SetOperation(add:LESS_EQUALS)
        end
        
        TypeCheckResult result = checker:Check(left:GetType(), right:GetType(), add)
        CompilerError error = result:GetCompilerError(context:GetLocation())
        if error not= undefined
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        Type value = result:result
        ComparisonOpcode compare = cast(ComparisonOpcode, result:GetQuorumOpcode())
        compare:SetLocation(context:GetLocation())
        compare:SetMethodWriter(methodWriter)
        compare:SetType(value)
        compare:SetLeftOpcode(left)
        compare:SetRightOpcode(right)
        opcodeStack:Push(compare)
    end

    action ExitEquals (EqualsContext context)
        TypeChecker checker = GetTypeChecker()
        QuorumOpcode right = opcodeStack:Pop()
        QuorumOpcode left = opcodeStack:Pop()
        Operation add
        if context:equalsTo
            add:SetOperation(add:EQUALS)
        else
            add:SetOperation(add:NOT_EQUALS)
        end

        if left = undefined or right = undefined
            return now //An error has already been issued.
        end
        
        TypeCheckResult result = checker:Check(left:GetType(), right:GetType(), add)
        CompilerError error = result:GetCompilerError(context:GetLocation())
        if error not= undefined
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        Type value = result:result
        ComparisonOpcode compare = cast(ComparisonOpcode, result:GetQuorumOpcode())
        compare:SetLocation(context:GetLocation())
        compare:SetMethodWriter(methodWriter)
        compare:SetType(value)
        compare:SetLeftOpcode(left)
        compare:SetRightOpcode(right)
        opcodeStack:Push(compare)
    end

    action EnterAnd(AndOrContext context) end
    action ExitAnd(AndOrContext context) 
        DoAndOr(context)
    end

    action DoAndOr(AndOrContext context)
        TypeChecker checker = GetTypeChecker()
        QuorumOpcode right = opcodeStack:Pop()
        QuorumOpcode left = opcodeStack:Pop()
        Operation op
        if context:isAnd
            op:SetOperation(op:AND)
        else 
            op:SetOperation(op:OR)
        end

        if left = undefined or right = undefined
            return now //An error has already been issued.
        end

        TypeCheckResult result = checker:Check(left:GetType(), right:GetType(), op)
        CompilerError error = result:GetCompilerError(context:GetLocation())
        if error not= undefined
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        Type value = result:result
        BinaryAndOrOpcode binary
        binary:SetLocation(context:GetLocation())
        binary:isAnd = context:isAnd
        binary:methodWriter = methodWriter
        binary:SetType(value)
        binary:SetOperation(op)
        binary:left = left
        binary:right = right

        if left is BinaryAndOrOpcode
            BinaryAndOrOpcode theAnd = cast(BinaryAndOrOpcode, left)
            theAnd:hasParent = true
            theAnd:opcodeParent = binary
            theAnd:isOnLeft = true
        end

        if right is BinaryAndOrOpcode
            BinaryAndOrOpcode theAnd = cast(BinaryAndOrOpcode, right)
            theAnd:hasParent = true
            theAnd:opcodeParent = binary
            theAnd:isOnLeft = false
        end
        opcodeStack:Push(binary)
    end

    action EnterOr(AndOrContext context) end
    action ExitOr(AndOrContext context)
        DoAndOr(context)
    end

    action ExitMultiplication(MultiplicationContext context) 
        TypeChecker checker = GetTypeChecker()
        QuorumOpcode right = opcodeStack:Pop()
        QuorumOpcode left = opcodeStack:Pop()
        Operation op
        if context:isDivide
            op:SetOperation(op:DIVIDE)
        elseif context:isMultiply
            op:SetOperation(op:TIMES)
        else
            op:SetOperation(op:MODULUS)
        end

        if left = undefined or right = undefined
            return now //An error has already been issued.
        end

        TypeCheckResult result = checker:Check(left:GetType(), right:GetType(), op)
        CompilerError error = result:GetCompilerError(context:GetLocation())
        if error not= undefined
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        Type value = result:result
        BinaryOpcode binary = cast(BinaryOpcode, result:GetQuorumOpcode())
        binary:SetLocation(context:GetLocation())
        binary:SetMethodWriter(methodWriter)
        binary:SetType(value)
        binary:SetLeftOpcode(left)
        binary:SetRightOpcode(right)
        opcodeStack:Push(binary)
    end

    action ExitAddition(AdditionContext addition) 
        TypeChecker checker = GetTypeChecker()
        QuorumOpcode right = opcodeStack:Pop()
        QuorumOpcode left = opcodeStack:Pop()
        Operation add
        if addition:isPlus
            add:SetOperation(add:PLUS)
        else
            add:SetOperation(add:MINUS)
        end

        if left = undefined or right = undefined
            return now //An error has already been issued.
        end

        TypeCheckResult result = checker:Check(left:GetType(), right:GetType(), add)
        CompilerError error = result:GetCompilerError(addition:GetLocation())
        if error not= undefined
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        Type value = result:result
        BinaryOpcode binary = cast(BinaryOpcode, result:GetQuorumOpcode())
        binary:SetLocation(addition:GetLocation())
        binary:SetMethodWriter(methodWriter)
        binary:SetType(value)
        binary:SetLeftOpcode(left)
        binary:SetRightOpcode(right)
        opcodeStack:Push(binary)
    end

    action ExitMinus(UnaryMinusContext context) 
        TypeChecker checker = GetTypeChecker()
        QuorumOpcode left = opcodeStack:Pop()

        Operation notOp
        notOp:SetOperation(notOp:MINUS)

        if left = undefined
            return now //An error has already been issued.
        end

        TypeCheckResult result = checker:Check(left:GetType(), notOp) 
        CompilerError error = result:GetCompilerError(context:GetLocation())
        if error not= undefined
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        Type value = result:result
        NegateUnaryOpcode binary = cast(NegateUnaryOpcode, result:GetQuorumOpcode())
        binary:SetLocation(context:GetLocation())
        binary:SetMethodWriter(methodWriter)
        binary:SetType(value)
        binary:SetOpcode(left)
        opcodeStack:Push(binary)
    end

    action ExitNot(NotContext context) 
        TypeChecker checker = GetTypeChecker()
        QuorumOpcode left = opcodeStack:Pop()

        Operation notOp
        notOp:SetOperation(notOp:NOT)

        if left = undefined
            return now //An error has already been issued.
        end

        TypeCheckResult result = checker:Check(left:GetType(), notOp) 
        CompilerError error = result:GetCompilerError(context:GetLocation())
        if error not= undefined
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        Type value = result:result
        FlipBooleanOpcode binary = cast(FlipBooleanOpcode, result:GetQuorumOpcode())
        binary:SetLocation(context:GetLocation())
        binary:SetMethodWriter(methodWriter)
        binary:SetType(value)
        binary:SetOpcode(left)
        opcodeStack:Push(binary)
    end

    action ExitMe(MeContext context) 
        MeOpcode opcode
        opcode:SetLocation(context:GetLocation())
        opcode:SetMethodWriter(methodWriter)
        opcode:SetThis(currentClass)
        opcodeStack:Push(opcode)
    end

    action ExitInput(InputContext context) 
        InputOpcode opcode
        opcode:SetLocation(context:GetLocation())
        opcode:SetMethodWriter(methodWriter)
        opcodeStack:Push(opcode)
    end

    action ExitUndefined(UndefinedContext context) 
        Type type
        type:SetIsConstant(true)
        type:SetToUndefined()

        QuorumConstant const
        const:SetLocation(context:GetLocation())
        const:SetMethodWriter(methodWriter)
        const:SetType(type)
        opcodeStack:Push(const)
    end

    action ExitInteger(IntegerContext context) 
        Type type
        type:SetIsConstant(true)
        type:SetIntegerConstant(context:value)

        QuorumConstant const
        const:SetLocation(context:GetLocation())
        const:SetMethodWriter(methodWriter)
        const:SetType(type)
        const:integerValue = context:value
        opcodeStack:Push(const)
    end
    
    action ExitText(TextContext context) 
        Type type
        type:SetIsConstant(true)
        type:SetTextConstant(context:value)

        QuorumConstant const
        const:SetLocation(context:GetLocation())
        const:SetMethodWriter(methodWriter)
        const:SetType(type)
        const:textValue = context:value
        opcodeStack:Push(const)
    end

    action ExitBoolean(BooleanContext context) 
        Type type
        type:SetIsConstant(true)
        type:SetBooleanConstant(context:value)

        QuorumConstant const
        const:SetLocation(context:GetLocation())
        const:SetMethodWriter(methodWriter)
        const:SetType(type)
        const:booleanValue = context:value
        opcodeStack:Push(const)
    end

    action ExitNumber(NumberContext context) 
        Type type
        type:SetIsConstant(true)
        type:SetNumberConstant(context:value)

        QuorumConstant const
        const:SetLocation(context:GetLocation())
        const:SetMethodWriter(methodWriter)
        const:SetType(type)
        const:numberValue = context:value
        opcodeStack:Push(const)
    end
end