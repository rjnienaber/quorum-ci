package Libraries.Language.Compile.Symbol

use Libraries.Language.Compile.QualifiedName
use Libraries.Language.Compile.CompilerError
use Libraries.Language.Compile.CompilerErrorType
use Libraries.Containers.HashTable
use Libraries.Language.Compile.Location
use Libraries.Containers.Blueprints.Iterator
use Libraries.Containers.Array
use Libraries.System.File
use Libraries.Language.Compile.Translate.QuorumOpcode

class Class is Symbol
    QualifiedName packageName
    HashTable<text, Action> actions
    HashTable<text, Variable> fields
    Action constructor = undefined
    boolean hasMain = false
    Array<QualifiedName> unresolvedUseStatements
    HashTable<text, Class> validUses
    HashTable<text, Class> validUsesFullyQualified
    File file = undefined

    action Add(Action method) returns CompilerError
        if not IsDefined(method)
            actions:Add(method:GetStaticKey(), method)
            if method:IsMain()
                hasMain = true
            end
            return undefined
        end

        CompilerError error
        error:SetLineNumber(method:GetLineNumber())
        error:SetFile(method:GetFile())
        error:SetErrorMessage("Action " + method:GetDisplayName() + " has already been defined.")
        return error
    end

    action AddValidUse(Class clazz) returns CompilerError
        name = clazz:GetName()
        if validUses:HasKey(name)
            Class defined = validUses:GetValue(name)
            CompilerError error
            CompilerErrorType type
            type:SetCurrentType(type:USE_AMBIGUOUS)
            error:SetCompilerErrorType(type)
            error:SetErrorMessage("I do not understand by defining " + name + " as type " + clazz:GetStaticKey() + "." + 
                " I already defined it as type " + defined:GetStaticKey() + ".")
            return error
        else
            validUses:Add(name, clazz)
            validUsesFullyQualified:Add(clazz:GetStaticKey(), clazz)
        end
        return undefined
    end

    /*
        Returns the file on disk that contains the implementation of this class.
    */
    action GetFile returns File
        return file
    end

    /*
        Sets a pointer to the file on disk that contains this class.
    */
    action SetFile(File container)
        file = container
    end

    action HasMainAction returns boolean
        return hasMain
    end

    action AddUnresolvedUseStatement(QualifiedName name)
        unresolvedUseStatements:Add(name)
    end

    action GetUnresolvedUseStatements returns Iterator<QualifiedName>
        return unresolvedUseStatements:GetIterator()
    end

    action Add(Variable variable) returns CompilerError
        if fields:HasKey(variable:GetStaticKey())
            CompilerError error
            error:SetLineNumber(variable:GetLineNumber())
            error:SetFile(variable:GetFile())
            error:SetErrorMessage("Variable " + variable:GetDisplayName() + " has already been defined in class " + me:GetDisplayName())
            return error
        end
        variable:SetIsField(true)
        fields:Add(variable:GetStaticKey(), variable)
        return undefined
    end

    action GetVariable(text key) returns Variable
        return fields:GetValue(key)
    end

    action GetAction(text key) returns Action
        return actions:GetValue(key)
    end

    action HasAction(text key) returns boolean
        return actions:HasKey(key)
    end

    private action IsDefined(Action method) returns boolean
        return actions:HasKey(method:GetStaticKey())
    end

    /*
        This action returns whether or not the class has an explicity constructor
        defined. If it returns true, the user has defined a constructor. If
        it returns false, they have not.
    */
    action HasConstructor returns boolean
        return constructor not= undefined
    end

    action GetConstructor returns Action
        return constructor
    end

    action SetConstructor(Action method) 
        constructor = method
    end

    action GetStaticKey returns text
        text pack = packageName:GetStaticKey()
        if pack:IsEmpty()
            return me:GetName()
        end
        return pack + "." + me:GetName()
    end

    action GetDisplayName returns text
        return GetStaticKey()
    end

    action GetPackage returns QualifiedName
        return packageName:Copy()
    end

    action ResolveAction(ActionCall call) returns ActionCallResolution
        ActionCallResolution resolution
        Array<QuorumOpcode> parameters = call:actualParameters

        Array<Action> named //actions with the right name
        Iterator<Action> all = actions:GetValueIterator()
        repeat while all:HasNext()
            Action act = all:Next()
            if act:GetName() = call:name //the name is right
                calledParameterSize = parameters:GetSize()
                actualParameterSize = act:GetParametersSize()

                if calledParameterSize = actualParameterSize //the number of parameters match
                    named:Add(act)
                end
            end
        end

        if named:IsEmpty()
            resolution:isResolved = false
            return resolution
        end

        //now check all of the parameters to see whether the types are compatible

        return resolution
    end

    action SetPackage(QualifiedName pack)
        packageName = pack:Copy()
    end
end