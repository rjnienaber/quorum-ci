package Libraries.Language.Compile

use Libraries.Language.Compile.Context.all
use Libraries.Containers.Stack
use Libraries.Language.Compile.Symbol.all
use Libraries.System.File
use Libraries.Containers.List
use Libraries.Containers.Blueprints.Iterator

class TypeCheckListener is QuorumSourceListener
    QualifiedName packageValue = undefined
    Action currentAction = undefined
    Class currentClass = undefined
    Block currentBlock = undefined
    boolean isInAction = false
    Stack<Block> blocks
    Stack<Type> expressionStack
    boolean isNextVariableReferenceMe = false
    Stack<integer> blockPositionStack
    integer loopCounter = 0

    action ExitPackageRule(PackageContext context) 
        packageValue = context:name
    end

    action EnterFullClassDeclaration(FullClassDeclarationContext context) 
        text name = context:className
        SymbolTable table = me:GetSymbolTable()
        
        text staticKey = ""
        if packageValue = undefined
            QualifiedName default
            packageValue = default
        end
        staticKey = packageValue:GetClassStaticKey(name)
        currentClass = table:GetClass(staticKey)

        if currentClass = undefined //throw an error
            Location location = context:GetLocation()
            CompilerError error
            error:SetLineNumber(location:GetLineNumber())
            error:SetFile(location:GetFile())
            error:SetErrorMessage("Class " + context:className + " could not be found.")
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
        end
    end

    action ExitActionHeader(ActionContext context)
        if currentClass not= undefined
            //get the method name
            text key = context:GetStaticKey()
            Action method = currentClass:GetAction(key)
            currentAction = method

            if currentAction = undefined //throw an error
                Location location = context:GetLocation()
                CompilerError error
                error:SetLineNumber(location:GetLineNumber())
                error:SetFile(location:GetFile())
                error:SetErrorMessage("Action " + key + " could not be found.")
                CompilerErrorManager manager = GetCompilerErrorManager()
                manager:Add(error)
            end
        end
    end

    action EnterBlock(BlockContext context)
        if currentBlock = undefined
            currentBlock = currentAction:GetBlock()
            blockPositionStack:Push(0)
        else 
            integer value = blockPositionStack:Pop()
            if value < currentBlock:GetSubBlockSize()
                currentBlock = currentBlock:GetBlock(value)
                blockPositionStack:Push(value + 1)
                //now push on a 0 for the new block
                blockPositionStack:Push(0)
            else 
                alert("Compiler Bug in EnterBlock of the Type Check Listener.")
            end
        end
    end
    
    action ExitBlock(BlockContext context)
        if currentBlock not= undefined
            Block temp = currentBlock
            currentBlock = currentBlock:GetParentBlock() //may be undefined
            //temp:AssignBytecodeLocations()
            blockPositionStack:Pop()
        end
    end

    action EnterAction(ActionContext context)
        isInAction = true
    end

    action ExitAction(ActionContext context) 
        if currentAction not= undefined
            Block b = currentAction:GetBlock()
            b:AssignBytecodeLocations()
            currentAction = undefined
        end
        isInAction = false
    end

    action EnterLoopStatement(LoopContext context)
        loopCounter = loopCounter + 1
    end

    action ExitNormalAssignment(NormalAssignmentContext context) 
        text name = context:name
        Variable variable = undefined

        if not isInAction
            variable = currentClass:GetVariable(name)
        else 
            variable = currentBlock:GetVariable(name)
        end
        
        if variable = undefined
            Location location = context:GetLocation()
            CompilerError error
            error:SetLineNumber(location:GetLineNumber())
            error:SetFile(location:GetFile())
            error:SetErrorMessage("Variable " + context:name + " could not be found.")
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        if not expressionStack:IsEmpty() //ignore the operation, a compiler error should have already been issued
            if context:hasRightHandSide = false
                Type typeOriginal = context:leftHandSide
                if typeOriginal:IsPrimitive()
                    Type type = typeOriginal:Copy()
                    type:SetIsConstant(true)
                    expressionStack:Push(type)
                end
            end
            Type right = expressionStack:Pop()
            integer bytecodeSize = right:GetBytecodeSize()

            TypeChecker checker = GetTypeChecker()
            TypeCheckResult result = checker:Check(variable:GetType(), right, undefined, true) 
            CompilerError error = result:GetCompilerError(context:GetLocation())
            if error not= undefined
                CompilerErrorManager manager = GetCompilerErrorManager()
                manager:Add(error)
                return now
            end

            expressionStack:Push(result:result)
        end
    end

    action ExitNoTypeAssignment(NoTypeAssignmentContext context) 
        text name = context:name
        Variable variable = undefined

        if context:hasMe or context:isField
            variable = currentClass:GetVariable(name)
        else 
            variable = currentBlock:GetVariable(name)
        end
        
        if variable = undefined
            Location location = context:GetLocation()
            CompilerError error
            error:SetLineNumber(location:GetLineNumber())
            error:SetFile(location:GetFile())
            error:SetErrorMessage("Variable " + context:name + " could not be found.")
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        Type type = expressionStack:Pop()
        integer bytecodeSize = type:GetBytecodeSize()
        if variable:IsDefined() //this is another assignment, not the initial one
            //ask the type checker if this assignment is legal
        else //this is an implicit cast, so make sure if follows the rules
            if variable:GetType() = undefined //implicit cast. If it follows the rules, allow it
                variable:SetType(type)
            end
        end
    end

    action EnterVariableFunctionCall(VariableFunctionCallContext context) 
        isNextVariableReferenceMe = context:hasMe
    end
    action ExitVariableFunctionCall(VariableFunctionCallContext context) 
        isNextVariableReferenceMe = false
    end

    action EnterActionCall(ActionCallContext context)
        if context:isActionCall 
        else 
            name = context:name
            Variable variable = undefined
            
            if isNextVariableReferenceMe
                variable = currentClass:GetVariable(name)
            else 
                variable = currentBlock:GetVariable(name)
                isNextVariableReferenceMe = false
            end

            Type type = variable:GetType()
            if variable:IsField()
            else
            end
            expressionStack:Push(type)
        end
    end

    action ExitAnd(AndOrContext context) 
        DoAndOr(context)
    end

    action ExitOr(AndOrContext context)
        DoAndOr(context)
    end

    action DoAndOr(AndOrContext context)
        TypeChecker checker = GetTypeChecker()
        Type right = expressionStack:Pop()
        Type left = expressionStack:Pop()
        Operation op
        if context:isAnd
            op:SetOperation(op:AND)
        else 
            op:SetOperation(op:OR)
        end

        TypeCheckResult result = checker:Check(left, right, op) 
        CompilerError error = result:GetCompilerError(context:GetLocation())
        if error not= undefined
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        expressionStack:Push(result:result)
    end

    action ExitEquals(EqualsContext context)
        TypeChecker checker = GetTypeChecker()
        Type right = expressionStack:Pop()
        Type left = expressionStack:Pop()
        Operation add
        if context:equalsTo
            add:SetOperation(add:EQUALS)
        else
            add:SetOperation(add:NOT_EQUALS)
        end
        
        TypeCheckResult result = checker:Check(left, right, add)
        CompilerError error = result:GetCompilerError(context:GetLocation())
        if error not= undefined
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end
        Type value = result:result
        expressionStack:Push(value:Copy())
    end

    action ExitInequality(InequalityContext context) 
        TypeChecker checker = GetTypeChecker()
        Type right = expressionStack:Pop()
        Type left = expressionStack:Pop()
        Operation add
        if context:isGreater
            add:SetOperation(add:GREATER)
        elseif context:isGreaterEquals
            add:SetOperation(add:GREATER_EQUALS)
        elseif context:isLess
            add:SetOperation(add:LESS)
        elseif context:isLessEquals
            add:SetOperation(add:LESS_EQUALS)
        end
        
        TypeCheckResult result = checker:Check(left, right, add)
        CompilerError error = result:GetCompilerError(context:GetLocation())
        if error not= undefined
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        expressionStack:Push(result:result)
    end


    action ExitAddition(AdditionContext context) 
        TypeChecker checker = GetTypeChecker()
        Type right = expressionStack:Pop()
        Type left = expressionStack:Pop()
        Operation add
        if context:isPlus
            add:SetOperation(add:PLUS)
        else
            add:SetOperation(add:MINUS)
        end
        
        TypeCheckResult result = checker:Check(left, right, add) 
        CompilerError error = result:GetCompilerError(context:GetLocation())
        if error not= undefined
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        expressionStack:Push(result:result)
    end

    action ExitMultiplication(MultiplicationContext context) 
        TypeChecker checker = GetTypeChecker()
        Type right = expressionStack:Pop()
        Type left = expressionStack:Pop()
        Operation op
        if context:isDivide
            op:SetOperation(op:DIVIDE)
        elseif context:isMultiply
            op:SetOperation(op:TIMES)
        else
            op:SetOperation(op:MODULUS)
        end

        TypeCheckResult result = checker:Check(left, right, op) 
        CompilerError error = result:GetCompilerError(context:GetLocation())
        if error not= undefined
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        expressionStack:Push(result:result)
    end

    action ExitInteger(IntegerContext context) 
        Type type
        type:SetIsConstant(true)
        type:SetIntegerConstant(context:value)
        expressionStack:Push(type)
    end
    
    action ExitText(TextContext context) 
        Type type
        type:SetIsConstant(true)
        type:SetTextConstant(context:value)
        expressionStack:Push(type)
    end

    action ExitBoolean(BooleanContext context) 
        Type type
        type:SetIsConstant(true)
        type:SetBooleanConstant(context:value)
        expressionStack:Push(type)
    end

    action ExitNumber(NumberContext context) 
        Type type
        type:SetIsConstant(true)
        type:SetNumberConstant(context:value)
        expressionStack:Push(type)
    end
end