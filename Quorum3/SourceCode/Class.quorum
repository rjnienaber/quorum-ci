package Libraries.Language.Compile.Symbol

use Libraries.Language.Compile.QualifiedName
use Libraries.Language.Compile.CompilerError
use Libraries.Language.Compile.CompilerErrorManager
use Libraries.Language.Compile.CompilerErrorType
use Libraries.Containers.HashTable
use Libraries.Language.Compile.Location
use Libraries.Containers.Blueprints.Iterator
use Libraries.Containers.Array
use Libraries.System.File
use Libraries.Language.Compile.Translate.QuorumOpcode

class Class is Symbol
    QualifiedName packageName
    HashTable<text, Action> actions
    HashTable<text, Action> virtualActions
    HashTable<text, Action> parentActions
    HashTable<text, Variable> fields
    Action constructor = undefined
    boolean hasMain = false
    HashTable<text, QualifiedName> unresolvedUseStatements
    Array<QualifiedName> unresolvedParents
    HashTable<text, Class> validUses
    HashTable<text, Class> validUsesFullyQualified
    HashTable<text, Class> parents
    Array<text> generics
    HashTable<text, integer> genericHash
    boolean areParentsResolved = false
    boolean isResolvingParents = false
    boolean isTypeResolved = false
    File file = undefined
    boolean hasSystemAction = false
    constant text LIBRARIES_LANGUAGE_OBJECT = "Libraries.Language.Object"
    boolean isMainClass = false

    on create
        QualifiedName object
        object:Add("Libraries")
        object:Add("Language")
        object:Add("Object")

        AddUnresolvedUseStatement(object)

//        QualifiedName textObject
//        textObject:Add("Libraries")
//        textObject:Add("Language")
//        textObject:Add("Types")
//        textObject:Add("Text")
//
//        AddUnresolvedUseStatement(textObject)

        QualifiedName booleanObject
        booleanObject:Add("Libraries")
        booleanObject:Add("Language")
        booleanObject:Add("Types")
        booleanObject:Add("Boolean")

        AddUnresolvedUseStatement(booleanObject)

        QualifiedName integerObject
        integerObject:Add("Libraries")
        integerObject:Add("Language")
        integerObject:Add("Types")
        integerObject:Add("Integer")

        AddUnresolvedUseStatement(integerObject)

        QualifiedName numberObject
        numberObject:Add("Libraries")
        numberObject:Add("Language")
        numberObject:Add("Types")
        numberObject:Add("Number")

        AddUnresolvedUseStatement(numberObject)
//
//        QualifiedName errorObject
//        errorObject:Add("Libraries")
//        errorObject:Add("Language")
//        errorObject:Add("Errors")
//        errorObject:Add("Error")
//
//        AddUnresolvedUseStatement(errorObject)
    end

        
    action IsProgramStartingClass returns boolean
        return isMainClass
    end

    action SetIsProgramStartingClass(boolean main)
        isMainClass = main
    end

    action AddGeneric(text name)
        generics:Add(name)
        genericHash:Add(name, generics:GetSize() - 1)
    end

    action GetNumberGenerics returns integer
        return generics:GetSize()
    end

    action GetGeneric(integer location) returns text
        return generics:Get(location)
    end

    /*
        This action determines whether a generic of a particular name 
        exists in this class.
    */
    action HasGeneric(text name) returns boolean
        return genericHash:HasKey(name)
    end

    /*
        This action digs through the generics and, if it finds one
        by this name, returns its index. If no generic by this name
        is found, then this returns -1.
    */
    action GetIndexOfGeneric(text name) returns integer
        if HasGeneric(name)
            return genericHash:GetValue(name)
        else
            return -1
        end
    end

    /*
        This action looks at all actions listed in this class's declared
        action table, in addition to those actions declared in parents,
        and fills up a new virtual action table with all actions combined.
        If this action has an error, it is created and sent to the 
        compiler error manager passed in.
    */
    action ComputeVirtualActionTable (CompilerErrorManager errors)
        Iterator<Action> declaredActions = GetActions()
        repeat while declaredActions:HasNext()
            Action act = declaredActions:Next()
            virtualActions:Add(act:GetStaticKey(), act)
        end

        //now dig through all parents and add any virtual methods that are
        //necessary
        Iterator<Class> parentIterator = GetParentClasses()
        repeat while parentIterator:HasNext()
            Class mom = parentIterator:Next()
            
            Iterator<Action> momActions = mom:GetActions()
            repeat while momActions:HasNext()
                Action act = momActions:Next()
                
                text key = act:GetStaticKey()
                Type returnType = act:GetReturnType()
                text returnKey = returnType:GetStaticKey()

                Action actionCopy = virtualActions:GetValue(key)
                if actionCopy = undefined //it doesn't exist, so add it.
                   virtualActions:Add(key, act) 
                   parentActions:Add(key, act) 
                else
                    //check to see if the action is overriden
                    Action baseAction = actions:GetValue(key)
                    
                    //if it exists, just make sure it has the same return type
                    if baseAction not= undefined
                        Class dad = baseAction:GetParentClass()
                        Type baseReturnType = baseAction:GetReturnType()
                        text baseReturnKey = baseReturnType:GetStaticKey()
                        if returnKey not= baseReturnKey //this is an error
                            CompilerError error
                            error:SetErrorMessage("The action " + key + " is defined in the parent "
                                + dad:GetStaticKey() + ", but the return types (" 
                                + baseReturnKey + " and "+ returnKey + ") do not match.")
                                error:SetLocation(act)
                            errors:Add(error)
                        end //otherwise, everything is fine, so ignore it
                    else //the base action is undefined, so this is an error, as
                         //multiple parents have the same action, but it is not overridden
                         //in the base class.
                         Class dad = actionCopy:GetParentClass()
                         CompilerError error
                         error:SetErrorMessage("The action " + key + " is defined "
                            +   " in the parent classes " + mom:GetStaticKey() + " and " 
                            + dad:GetStaticKey() + ". I cannot determine which action should "
                            + " be called and therefore the action must be overriden in the "
                            + " base class " + me:GetStaticKey())
                         error:SetLocation(act)
                         errors:Add(error)
                    end
                end
            end
        end
    end

    action GetVirtualTable returns Iterator<Action>
        return virtualActions:GetValueIterator()
    end

    action GetParentActions returns Iterator<Action> 
        return parentActions:GetValueIterator()
    end

    /*
        This action returns a list of of all generic names. For example, if
        the class is declared as A<Type, Value>, then this action will return
        "Type, Value" without double quotes.
    */ 
    action GetGenericList returns text
        text value = ""
        
        i = 0
        repeat GetNumberGenerics() times
            if i = 0
                value = value + GetGeneric(i)
            else 
                value = value + ", " + GetGeneric(i)
            end
            i = i + 1
        end
        return value
    end

    action Add(Action method) returns CompilerError
        if not IsDefined(method)
            actions:Add(method:GetStaticKey(), method)
            if method:IsMain()
                hasMain = true
            end

            if method:IsSystem()
                hasSystemAction = true
            end
            return undefined
        end

        CompilerError error
        error:SetLineNumber(method:GetLineNumber())
        error:SetFile(method:GetFile())
        error:SetErrorMessage("Action " + method:GetDisplayName() + " has already been defined.")
        return error
    end

    action HasSystemAction returns boolean
        return hasSystemAction
    end

    /*
        This action returns whether or not this particular class
        represents Libraries.Language.Object.
    */
    action IsObject returns boolean
        if GetStaticKey() = LIBRARIES_LANGUAGE_OBJECT
            return true
        else
            return false
        end
    end

    action GenerateSetterNameFromField(Variable variable) returns text
        text result = "Set$"
        result = result + ConvertStaticKeyToFieldPath() + variable:GetName()
        return result
    end

    action ConvertToActionNameFromField(Variable variable, boolean isGetter) returns text
        text result = ""

        if isGetter
            result = result + "Get$"
        else
            result = result + "Set$"
        end
        
        result = result + ConvertStaticKeyToFieldPath() + "$" + variable:GetName()
        return result
    end

    action AddUnresolvedParent(QualifiedName name)
        unresolvedParents:Add(name)
    end

    action AddParentClass(Class clazz) //check for compiler error or just ignore?
        parents:Add(clazz:GetStaticKey(), clazz)
    end
    
    /*
        This action checks to see if all types have been resolved for this class.
    */
    action IsResolved returns boolean
        return isTypeResolved
    end

    action ResolveAllTypes(SymbolTable table, CompilerErrorManager errors)
        //first resolve all use statements
        Iterator<QualifiedName> unresolvedUse = GetUnresolvedUseStatements()
        repeat while unresolvedUse:HasNext()
            QualifiedName name = unresolvedUse:Next()
            Class clazz = GetClass(name:GetStaticKey(), table, errors)
            if clazz not= undefined
                AddValidUse(clazz)
            else
                CompilerError error
                error:SetLocation(name)
                CompilerErrorType type
                type:SetCurrentType(type:MISSING_USE)
                error:SetCompilerErrorType(type)
                error:SetErrorMessage("I could not locate the use statement named "
                    +   name:GetStaticKey() + ". Are you sure you spelled it correct?" )
                errors:Add(error)
            end
        end

        //next resolve all parents
        ResolveParents(table, errors)

        //now resolve all the fields
        ResolveFields(table, errors)

        //next resolve all actions and their blocks
        ResolveActions(table, errors)

        isTypeResolved = true
    end

    private action ResolveFields(SymbolTable table, CompilerErrorManager errors)
        Iterator<Variable> iterator = GetVariables()    
        repeat while iterator:HasNext()
            Variable var = iterator:Next()
            ResolveVariable(var, table, errors)
        end
    end

    action GetInterfaceName returns text
        text name = GetName()
        return name + "$Interface"
    end

    private action ResolveActions(SymbolTable table, CompilerErrorManager errors)
        Iterator<Action> actionIterator = me:GetActions()
        Array<Action> temp
        repeat while actionIterator:HasNext()
            Action next = actionIterator:Next()
            temp:Add(next)
            //first, we resolve the parameters
            Iterator<Variable> parameters = next:GetParameterIterator()
            repeat while parameters:HasNext()
                Variable param = parameters:Next()
                ResolveVariable(param, table, errors)
            end

            Type returnType = next:GetReturnType()
            if not returnType:IsVoid()
                ResolveType(next, returnType, table, errors)
            end

            //next we resolve all of the variables in its blocks
            if next:GetBlock() not= undefined
                ResolveBlock(next:GetBlock(), table, errors)
            end
        end

        //now resolve the constructor, if one exists
        Action constructor = GetConstructor()
        if constructor not= undefined
            ResolveBlock(constructor:GetBlock(), table, errors)
        end

        //now we pull all actions out of the hash and re-hash them,
        //now with resolved type names and keys
        hasMain = false
        actions:Empty()
        actionIterator = temp:GetIterator()
        repeat while actionIterator:HasNext()
            Action next = actionIterator:Next()
            CompilerError error = Add(next)
            if error not= undefined
                errors:Add(error)
            end
        end
    end

    action ResolveFrames
        Iterator<Action> actionIterator = me:GetActions()
        repeat while actionIterator:HasNext()
            Action next = actionIterator:Next()
            if not next:IsSystem() and not next:IsBlueprint()
                Block b = next:GetBlock()
                b:AssignBytecodeLocations()
            end
        end
        if constructor not= undefined
            Block b = constructor:GetBlock()
            b:AssignBytecodeLocations()
        end
    end

    private action ResolveBlock(Block block, SymbolTable table, CompilerErrorManager errors)
        //first resolve all of the variables in this block
        Iterator<Variable> variables = block:GetVariables()
        repeat while variables:HasNext()
            Variable next = variables:Next()
            ResolveVariable(next, table, errors)
        end

        //next resolve any variables in the children
        Iterator<Block> blocks = block:GetBlocks()
        repeat while blocks:HasNext()
            Block next = blocks:Next()
            ResolveBlock(next, table, errors)
        end
    end

    private action ResolveVariable(Variable variable, SymbolTable table, CompilerErrorManager errors)
        Type type = variable:GetType()
        if type = undefined //this is an implicit type, which has to be a primitive
                            //therefore, it is safe to ignore this
            return now
        end
        ResolveType(variable, type, table, errors)
    end

    action ResolveType(Location location, Type type, SymbolTable table, CompilerErrorManager errors)
        if not type:IsPrimitive() //if it's a primitive, do nothing
            text key = type:GetStaticKey()
            Class clazz = GetClass(key, table, errors)
            if clazz not= undefined
                type:SetToObject(clazz:GetStaticKey())
                if type:HasGenerics()
                    //check to see if the number of generics matches with the class
                    if clazz:GetNumberGenerics() not= type:GetNumberGenerics() 
                        CompilerError error
                        error:SetLocation(location)
                        CompilerErrorType t
                        t:SetCurrentType(t:MISMATCHED_TEMPLATES)
                        error:SetCompilerErrorType(t)
                        error:SetErrorMessage("I noticed there is a variable of type "
                            +  key + ". This class requires " + clazz:GetNumberGenerics()
                            + " generics, but there are " + type:GetNumberGenerics() + " defined.")
                        errors:Add(error)
                    end


                    Iterator<Type> generics = type:GetGenerics()
                    repeat while generics:HasNext()
                        Type generic = generics:Next()
                        if type:HasGenerics()
                            ResolveType(location, generic, table, errors)
                        end
                    end
                end
            else
                CompilerError error
                error:SetLocation(location)
                CompilerErrorType t
                t:SetCurrentType(t:MISSING_USE)
                error:SetCompilerErrorType(t)
                error:SetErrorMessage("I could not locate a type named "
                    +  key + ". Are you sure it was spelled it correct?" )
                errors:Add(error)
            end
        end
    end

    private action ResolveType(Variable variable, Type type, SymbolTable table, CompilerErrorManager errors)
        if not type:IsPrimitive() //if it's a primitive, do nothing
            text key = type:GetStaticKey()
            Class clazz = GetClass(key, table, errors)
            if clazz not= undefined
                type:SetToObject(clazz:GetStaticKey())
                if type:HasGenerics()
                    //check to see if the number of generics matches with the class
                    if clazz:GetNumberGenerics() not= type:GetNumberGenerics() 
                        CompilerError error
                        error:SetLocation(variable)
                        CompilerErrorType t
                        t:SetCurrentType(t:MISMATCHED_TEMPLATES)
                        error:SetCompilerErrorType(t)
                        error:SetErrorMessage("I noticed there is a variable of type "
                            +  key + ". This class requires " + clazz:GetNumberGenerics()
                            + " generics, but there are " + type:GetNumberGenerics() + " defined.")
                        errors:Add(error)
                    end


                    Iterator<Type> generics = type:GetGenerics()
                    repeat while generics:HasNext()
                        Type generic = generics:Next()
                        if type:HasGenerics()
                            ResolveType(variable, generic, table, errors)
                        end
                    end
                end
            else
                CompilerError error
                error:SetLocation(variable)
                CompilerErrorType t
                t:SetCurrentType(t:MISSING_USE)
                error:SetCompilerErrorType(t)
                error:SetErrorMessage("I could not locate a type named "
                    +  key + ". Are you sure it was spelled it correct?" )
                errors:Add(error)
            end
        end
    end

    /*
        This action resolves a type that lives in an action.
    */
    private action ResolveType(Action act, Type type, SymbolTable table, CompilerErrorManager errors)
        if not type:IsPrimitive() //if it's a primitive, do nothing
            text key = type:GetStaticKey()
            Class parentForAction = act:GetParentClass()
            if parentForAction:HasGeneric(type:GetStaticKey())
                //this is referencing a generic, so there's no need to check
                //the symbol table. Grab Object and tell it its mapped
                //generic name
                type:MapToGeneric(key)
                type:SetToObject(type:OBJECT_KEY)
                return now
            end

            Class clazz = GetClass(key, table, errors)
            if clazz not= undefined
                type:SetToObject(clazz:GetStaticKey())
                if type:HasGenerics()
                    //check to see if the number of generics matches with the class
                    if clazz:GetNumberGenerics() not= type:GetNumberGenerics() 
                        CompilerError error
                        error:SetLocation(act)
                        CompilerErrorType t
                        t:SetCurrentType(t:MISMATCHED_TEMPLATES)
                        error:SetCompilerErrorType(t)
                        error:SetErrorMessage("I noticed there is a variable of type "
                            +  key + ". This class requires " + clazz:GetNumberGenerics()
                            + " generics, but there are " + type:GetNumberGenerics() + " defined.")
                        errors:Add(error)
                    end


                    Iterator<Type> generics = type:GetGenerics()
                    repeat while generics:HasNext()
                        Type generic = generics:Next()
                        if type:HasGenerics()
                            ResolveType(act, generic, table, errors)
                        end
                    end
                end
            else
                CompilerError error
                error:SetLocation(act)
                CompilerErrorType t
                t:SetCurrentType(t:MISSING_USE)
                error:SetCompilerErrorType(t)
                error:SetErrorMessage("I could not locate a type named "
                    +  key + ". Are you sure it was spelled it correct?" )
                errors:Add(error)
            end
        end
    end

    action ResolveActionKey(text name, Iterator<Variable> parameters, 
        SymbolTable table, CompilerErrorManager errors) returns text
        text final = name
        
        repeat while parameters:HasNext()
            Variable param = parameters:Next()
            Type type = param:GetType()
            if type:IsPrimitive()
                final = final + ":" + type:GetStaticKey() 
            else
                Class clazz = GetClass(type:GetStaticKey(), table, errors)
                if clazz not= undefined //if it is, an error has been issued
                    final = final + ":" + clazz:GetStaticKey()
                end

                //does the type have generics
                //if type:HasGenerics()
                //    Iterator<Type> generics = type:GetGenerics()
                //    final = final + GetGenericKey(generics, table, errors)
                //end
            end
        end

        return final
    end

    private action GetGenericKey(Iterator<Type> generics, 
        SymbolTable table, CompilerErrorManager errors) returns text
        text final = "<"
        first = true
        repeat while generics:HasNext()
            Type type = generics:Next()
            
            if type:IsPrimitive()
                if first
                    final = final + type:GetStaticKey() 
                    first = false
                else
                    final = final + ":" + type:GetStaticKey() 
                end
                
            else
                Class clazz = GetClass(type:GetStaticKey(), table, errors)
                if clazz not= undefined //if it is, an error has been issued
                    if first
                        final = final + clazz:GetStaticKey()
                        first = false
                    else
                        final = final + ":" + clazz:GetStaticKey()
                    end
                    
                end

                //does the type have generics
                if type:HasGenerics()
                    Iterator<Type> gen = type:GetGenerics()
                    final = final + GetGenericKey(gen, table, errors)
                end
            end
        end

        return final + ">"
    end

    private action GetClass(text key, SymbolTable table, CompilerErrorManager errors) returns Class
        Class clazz = undefined
        Array<text> split = key:Split("\.")

        //first check if this is a full name in the symbol table. 
        //be careful to check the default package only if this class
        //is in the default package. 
        if split:GetSize() > 1
            clazz = table:GetClass(key)
        end

        if clazz not= undefined
            return clazz
        end
        //next check if this is the name of a generic in this class
        has = HasGeneric(key)
        if has
            Type type
            clazz = table:GetClass(type:OBJECT_KEY)
        end

        if clazz not= undefined
            return clazz
        end

        //if we still haven't found it, then check if there are any classes
        //in the current package of the class by that name. If there are, then
        //use that.
        Class fromPackage = table:GetClassInPackage(me:GetPackageKey(), key)

        //is there a name in the use list?
        Class fromUse = me:GetValidUseName(key)

        //is there a name in both the use list and the package?
        //if so, it's a compiler error if they conflict
        //if no name is found, this is an error
        //if the name is unique, use that one and put it in the class
        if fromPackage not= undefined and fromUse = undefined
            clazz = fromPackage
        elseif fromPackage = undefined and fromUse not= undefined
            clazz = fromUse
        elseif fromPackage not= undefined and fromUse not= undefined
            //if both classes are the same, then return it
            if fromPackage:GetStaticKey() = fromUse:GetStaticKey()
                clazz = fromPackage
            else //this is a conflict and a compiler error
                CompilerError error
                text a = ""
                a = a:GetDoubleQuote()
                error:SetErrorMessage("The name " + a + key + a
                    + " could be either " + a + fromPackage:GetStaticKey() + a 
                    + " or " + a + fromUse:GetStaticKey() + a + ". I cannot tell which one you meant." ) 
                //TODO: Add in compiler error line and location.
                errors:Add(error)
            end
        end

        if clazz not= undefined
            return clazz
        end

        if clazz = undefined
            CompilerError error
            text a = ""
            a = a:GetDoubleQuote()
            error:SetErrorMessage("The class name " + a + key + a + 
                " could not be found. Did you forget a use statement?") 
            //TODO: Add in compiler error line and location.
            errors:Add(error)
        end
        //if we still have not found the class, then it cannot be found, 
        //which is an error
        return undefined
    end


    action ResolveParents(SymbolTable table, CompilerErrorManager errors)
        isResolvingParents = true
        Iterator<QualifiedName> names = GetUnresolvedParents()
        repeat while names:HasNext()
            QualifiedName name = names:Next()
            Class myParent = GetClass(name:GetStaticKey(), table, errors)

            if myParent not= undefined //if it is defined, add it as a valid parent
                parents:Add(myParent:GetStaticKey(), myParent)
            end //if it is not, ignore it, as an error has already been issued
        end

        //ok, we now have all first level parents, so check them all
        //if they are already resolved, then flatten their lists and check
        //for circular dependencies
        //if the parents are not resolved, then resolve them before doing this.
        //since each parent's list is flattened after solution,
        //this does not need to go another level deeper.
        Iterator<Class> parentIterator = parents:GetValueIterator()
        repeat while parentIterator:HasNext()
            Class next = parentIterator:Next()
            
            //if this parent is in the middle of a ResolveParents call
            //we have a circular dependency and should throw a compiler error
            //we should also bail out at this point, because the behavior
            //would make no sense
            if next:IsResolvingParents()
                CompilerError error
                text a = ""
                a = a:GetDoubleQuote()
                error:SetErrorMessage("The parent name " + a + next:GetStaticKey() + a + 
                    " has the current class as a parent, but I do not understand what this would mean.") 
                //TODO: Add in compiler error line and location.
                errors:Add(error)

                isResolvingParents = false
                areParentsResolved = true
            end


            //otherwise check if the parent is resolved
            if not next:AreParentsResolved()
                next:ResolveParents(table, errors)
            end
            //the parent is now resolved. 
            Iterator<Class> list = next:GetParentClasses()
            repeat while list:HasNext()
                Class possibleParent = list:Next()
                //if this parent is not in our list, add it
                if not parents:HasKey(possibleParent:GetStaticKey())
                    parents:Add(possibleParent:GetStaticKey(), possibleParent)
                end
            end
        end

        //regardless of whether the user has errors in their code,
        //the parents have been resolved.
        isResolvingParents = false
        areParentsResolved = true
    end

    /*
        This action returns true only if the action ResolveParents is currently
        executing for this class. It is useful in detecting circular inheritance,
        which is not allowed in Quorum.
    */
    action IsResolvingParents returns boolean
        return isResolvingParents
    end

    /*
        This action determines whether this class has a complete
        flattened list of parents from all possible super-classes.
        For example, if we have a class A is B, class B is C, and class C is D,
        then the flattened list of A is B, C, D, and Libraries.Language.Object.
    */
    private action AreParentsResolved returns boolean
        return me:areParentsResolved
    end

    action HasParentClass(text key) returns boolean
        return parents:GetValue(key) not= undefined
    end

    action GetParentClass(text key) returns Class
        return parents:GetValue(key)
    end

    action GetParentClasses returns Iterator<Class>
        return parents:GetValueIterator()
    end

    action AddValidUse(Class clazz) returns CompilerError
        name = clazz:GetName()
        if validUses:HasKey(name)
            Class defined = validUses:GetValue(name)
            CompilerError error
            CompilerErrorType type
            type:SetCurrentType(type:USE_AMBIGUOUS)
            error:SetCompilerErrorType(type)
            error:SetErrorMessage("I do not understand by defining " + name + " as type " + clazz:GetStaticKey() + "." + 
                " I already defined it as type " + defined:GetStaticKey() + ".")
            return error
        else
            validUses:Add(name, clazz)
            validUsesFullyQualified:Add(clazz:GetStaticKey(), clazz)
        end
        return undefined
    end

    /*
        Returns the file on disk that contains the implementation of this class.
    */
    action GetFile returns File
        return file
    end

    /*
        Sets a pointer to the file on disk that contains this class.
    */
    action SetFile(File container)
        file = container
    end

    action HasMainAction returns boolean
        if actions:GetValue("Main") not= undefined
            return true
        end
        return false
    end

    action AddUnresolvedUseStatement(QualifiedName name)
        unresolvedUseStatements:Add(name:GetName(), name)
    end

    action GetUnresolvedUseStatement(text key) returns QualifiedName
        return unresolvedUseStatements:GetValue(key)
    end

    action GetUnresolvedUseStatements returns Iterator<QualifiedName>
        return unresolvedUseStatements:GetValueIterator()
    end

    action GetUnresolvedParents returns Iterator<QualifiedName>
        return unresolvedParents:GetIterator()
    end

    /*
        This action returns a class from a name, like Object, for
        Libraries.Language.Object. It assumes that the name passed in is
        not resolved. Fully resolvable names (Libraries.Language.Object) will
        not be resolved by this action, and as such, need to be resolved
        from the symbol table.
    */
    action GetValidUseName(text name) returns Class
        if validUses:HasKey(name)
            return validUses:GetValue(name)
        end

        return undefined
    end

    action Add(Variable variable) returns CompilerError
        if fields:HasKey(variable:GetStaticKey())
            CompilerError error
            error:SetLineNumber(variable:GetLineNumber())
            error:SetFile(variable:GetFile())
            error:SetErrorMessage("Variable " + variable:GetDisplayName() + " has already been defined in class " + me:GetDisplayName())
            return error
        end
        variable:SetIsField(true)
        fields:Add(variable:GetStaticKey(), variable)
        return undefined
    end

    action GetVariable(text key) returns Variable
        return fields:GetValue(key)
    end

    action GetVariables returns Iterator<Variable> 
        return fields:GetValueIterator()
    end

    action GetAction(text key) returns Action
        return actions:GetValue(key)
    end

    action GetVirtualAction(text key) returns Action
        return virtualActions:GetValue(key)
    end

    action GetActions returns Iterator<Action>
        return actions:GetValueIterator()
    end

    action HasAction(text key) returns boolean
        return actions:HasKey(key)
    end

    private action IsDefined(Action method) returns boolean
        return actions:HasKey(method:GetStaticKey())
    end

    /*
        This action returns whether or not the class has an explicity constructor
        defined. If it returns true, the user has defined a constructor. If
        it returns false, they have not.
    */
    action HasConstructor returns boolean
        return constructor not= undefined
    end

    action GetConstructor returns Action
        return constructor
    end

    action SetConstructor(Action method) 
        constructor = method
    end

    action GetStaticKey returns text
        text pack = packageName:GetStaticKey()
        if pack:IsEmpty()
            return me:GetName()
        end
        return pack + "." + me:GetName()
    end

    /*
        This action returns the static key formatted as a class name in 
        Java bytecode.
    */
    action ConvertStaticKeyToBytecodePath returns text
        text key = GetStaticKey()
        text result = "quorum/" + key:Replace(".", "/")
        return result
    end

    action ConvertStaticKeyToUnderScore returns text
        text key = GetStaticKey()
        text result = "$quorum_" + key:Replace(".", "_")
        return result
    end
    
    /*
        This action returns the static key formatted as a class name in 
        the style of a field.
    */
    action ConvertStaticKeyToFieldPath returns text
        text key = GetStaticKey()
        text result = key:Replace(".", "$")
        return result
    end

    /*
        This action returns the static key formatted as a class name in 
        Java bytecode.
    */
    action ConvertStaticKeyToBytecodeInterfacePath returns text
        text key = GetStaticKey()
        text result = "quorum/" + key:Replace(".", "/") + "$Interface"
        return result
    end

    /*
        This action returns the static key formatted as a plugin class name in 
        Java bytecode.
    */
    action ConvertStaticKeyToPluginPath returns text
        text key = GetStaticKey()
        text result = "plugins/quorum/" + key:Replace(".", "/")
        return result
    end

    /*
        This action returns the static key formatted as a plugin class type name in 
        Java bytecode.
    */
    action ConvertStaticKeyToPluginPathTypeName returns text
        text key = GetStaticKey()
        text result = "Lplugins/quorum/" + key:Replace(".", "/") + ";"
        return result
    end

    /*
        Returns the name of the plugin for this class.
    */
    action GetPluginName returns text
        return "<plugin>"
    end

    /*
        This action returns the static key formatted as a type name in
        Java bytecode.
    */
    action ConvertStaticKeyToBytecodePathTypeName returns text
        text key = GetStaticKey()
        text result = "Lquorum/" + key:Replace(".", "/") + ";"
        return result
    end

    /*
        This action returns the static key formatted as a type name in
        Java bytecode. This version acts as an interface type.
    */
    action ConvertStaticKeyToBytecodePathTypeNameInterface returns text
        text key = GetStaticKey()
        text result = "Lquorum/" + key:Replace(".", "/") + "$Interface;"
        return result
    end

    action GetHiddenVariableName() returns text
        return "$hidden$"
    end

    /*
        This action converts the static key of this class to a 
        name that can be used by the compiler as a class field name.
        An example would be that Libraries.Language.Object becomes
        $Libraries/Language/Object.
    */
    action ConvertStaticKeyToParentFieldName returns text
        text key = GetStaticKey()
        text result = "$" + key:Replace(".", "$")
        return result
    end

    /*
        This action converts the static key of this class to a 
        name that can be used by the compiler as a class field name.
        An example would be that Libraries.Language.Object becomes
        $Libraries/Language/Object.
    */
    action ConvertStaticKeyToParentFieldInterfaceName returns text
        text key = GetStaticKey()
        text result = "$" + key:Replace(".", "$") + "$Interface"
        return result
    end

    /*
        This returns a key related to the package a class is contained in. For
        example, if a class's fully qualified name is Libraries.Language.Object,
        then this would return Libraries.Langauge. If the class's fully qualified
        name is Bob, then this would return the empty string, which indicates
        the default package.
    */
    action GetPackageKey returns text
        text pack = packageName:GetStaticKey()
        return pack
    end

    action GetDisplayName returns text
        return GetStaticKey()
    end

    action GetPackage returns QualifiedName
        return packageName:Copy()
    end

    action ResolveAction(ActionCall call) returns ActionCallResolution
        ActionCallResolution resolution
        Array<Type> parameters = call:actualParameters
        TypeChecker checker = call:checker

        Array<Action> named //actions with the right name
        Array<integer> scores
        Array<Action> matches
        Iterator<Action> all = virtualActions:GetValueIterator()
        repeat while all:HasNext()
            Action act = all:Next()
            if act:GetName() = call:name //the name is right
                calledParameterSize = parameters:GetSize()
                actualParameterSize = act:GetParametersSize()

                if calledParameterSize = actualParameterSize //the number of parameters match
                    named:Add(act)
                end
            end
        end

        if named:IsEmpty()
            resolution:isResolved = false
            CompilerError error
            error:SetLocation(call)
            //TODO: Improve this error message
            error:SetErrorMessage("I could not find an action named '" + 
                call:name + "' in the class '" + me:GetStaticKey() + "'")
            error:SetLocation(call)
            resolution:error = error
            return resolution
        end
        Operation implicit
        implicit:SetOperation(implicit:IMPLICIT_CAST)

        Iterator<Action> it = named:GetIterator()
        //assume they have an equal number of parameters
        repeat while it:HasNext() 
            Action act = it:Next()
            i = 0
            integer actionPoints = 0
            Iterator<Variable> variables = act:GetParameterIterator()
            boolean isMatch = true
            repeat while variables:HasNext() and isMatch
                Variable formalParameter = variables:Next()
                Type formalParameterType = formalParameter:GetType()
                Type actualParameterType = parameters:Get(i)
                
                //Check the types to make sure that they are compatible
                TypeCheckResult result = checker:Check(formalParameterType, actualParameterType, implicit, false)
                CompilerError error = result:GetCompilerError(call)
                if error not= undefined //this action is not a match. We can break out
                    isMatch = false
                else 
                    TypeConversionPoints points = result:points
                    actionPoints = actionPoints + points:GetPoints()
                end
                i = i + 1
            end

            if isMatch
                matches:Add(act)
                scores:Add(actionPoints)
            end
        end
        
        Array<Action> finalMatches
        integer minPoints = 0
        minPoints = minPoints:GetMaximumValue()
        i = 0
        repeat matches:GetSize() times
            Action act = matches:Get(i)
            integer points = scores:Get(i)
            
            if points < minPoints
                minPoints = points
                finalMatches:Empty()
                finalMatches:Add(act)
            elseif points = minPoints
                finalMatches:Add(act)
            end

            i = i + 1
        end

        if finalMatches:GetSize() = 1
            resolution:resolvedAction = finalMatches:Get(0)
            Action final = finalMatches:Get(0)
            //now compute any implicit casts, if there are any
            Array<QuorumOpcode> casts
            Iterator<Variable> variables = final:GetParameterIterator()
            i = 0
            repeat while variables:HasNext()
                Type actual = parameters:Get(i)
                text actualText = actual:GetStaticKey()
                Variable var = variables:Next()
                Type formal = var:GetType()
                text formalText = formal:GetStaticKey()
                TypeCheckResult result = checker:Check(formal, actual, implicit, false)
                //this has to be correct, as it has already been checked
                TypeConversionConstants constants = result:conversion
                if constants:GetConversion() = constants:NONE
                    casts:Add(undefined)
                else
                    QuorumOpcode op = result:GetQuorumOpcode()
                    casts:Add(op)
                end
                resolution:converter = casts

                i = i + 1
            end


            resolution:isResolved = true
        elseif finalMatches:GetSize() > 1 //check all of the scores
            resolution:resolvedAction = undefined
            resolution:isResolved = false
            CompilerError error

            text value = "I could not find an action that uniquely matches with the name '" + 
                call:name + "' in the class '" + me:GetStaticKey() + "' The reason is because the actions "

             Iterator<Action> m = finalMatches:GetIterator()
             repeat while m:HasNext()
                Action a = m:Next()
                value = value + a:GetStaticKey()

                if m:HasNext()
                    value = value + ", and "
                end
             end
             value = value + " all match the parameters."
             
            //TODO: Improve this error message
            error:SetErrorMessage(value)
            error:SetLocation(call)
            resolution:error = error
        else //There are no matches
            resolution:resolvedAction = undefined
            resolution:isResolved = false
            CompilerError error
            error:SetLocation(call)
            //TODO: Improve this error message
            error:SetErrorMessage("I could not find an action named '" + 
                call:name + "' in the class '" + me:GetStaticKey() + "'")
            resolution:error = error
        end

        return resolution
    end

    action SetPackage(QualifiedName pack)
        packageName = pack:Copy()
    end
end