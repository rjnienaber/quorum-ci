package Libraries.Language.Compile

use Libraries.System.File
use Libraries.Language.Compile.Symbol.all
use Libraries.Containers.HashTable
use Libraries.Containers.Array
use Libraries.Containers.Blueprints.Iterator
use Libraries.Language.Compile.Translate.QuorumJarGenerator
use Libraries.Containers.List

class Compiler
    public constant number VERSION = 3.0
    File main = undefined
    constant text DEFAULT_BUILD_FOLDER = "TestBuild"
    constant text DEFAULT_RUN_FOLDER = "TestRun"
    constant text DEFAULT_STANDARD_LIBRARY_FOLDER = "Library/Standard"
    constant text OBJECT = "Libraries.Language.Object"
    File buildFolder = undefined
    File runFolder = undefined
    File standardLibraryFolder = undefined
    HashTable<text, Dependency> dependencies

    boolean isWebApplication = false
    text name = "Default"

    //Support classes
    SymbolTable symbolTable
    CompilerErrorManager compilerErrorManager
    TypeChecker checker

    on create //load default dependencies
        standardLibraryFolder = GetStandardLibraryFolder()
        LoadDependency("/" + DEFAULT_BUILD_FOLDER + "/quorum", "/quorum")
        LoadDependency("/Library/Standard/Plugins/plugins", "/plugins")
        //LoadDependency("/antlr", "/antlr")
        //LoadDependency("/asm", "/asm")
    end

    action LoadDependency(text from, text to)
        Dependency dep
        dep:from = from
        dep:to = to
        dependencies:Add(from, dep)
    end

    action GetDependencies returns Iterator<Dependency>
        return dependencies:GetValueIterator()
    end

    /*
        This action compiles the array of files to Java Bytecode, which
        it writes to disk. By default, it generates a .jar file into the 
        folder named Run and the class files into the folder labeled
        Build.
    */
    action Compile(Array<File> files)

        i = 0
        repeat while i < files:GetSize()
            File file = files:Get(i)
            Parser listener
            Parse(file, listener)
            i = i + 1
        end
        
        //This array will contain all files that must be built, 
        //including potentially some from the standard library
        //in order to build the requested files
        Array<File> allFiles = undefined
        if compilerErrorManager:IsCompilationErrorFree()
            allFiles = GetAllRequiredFiles()
        end

        if compilerErrorManager:IsCompilationErrorFree()
            TypeResolution()
        end

        if compilerErrorManager:IsCompilationErrorFree()
            i = 0
            repeat while i < allFiles:GetSize()
                File file = allFiles:Get(i)
                TypeCheckListener listener
                Parse(file, listener)
                i = i + 1
            end
        end

        if compilerErrorManager:IsCompilationErrorFree()
            i = 0
            repeat while i < allFiles:GetSize()
                File file = allFiles:Get(i)
                QuorumBytecodeListener listener
                Parse(file, listener)
                i = i + 1
            end
        end

        if compilerErrorManager:IsCompilationErrorFree()
            QuorumJarGenerator generator
            File jar = GetDistributionFile()
            generator:SetCompiler(me)
            generator:Write()
        end
    end

    action TypeResolution
        Iterator<Class> classes = symbolTable:GetClasses()
        repeat while classes:HasNext()
            Class next = classes:Next()

            //because of the way the parent flattening algorithm works,
            //classes may already be resolved
            if not next:IsResolved()
                next:ResolveAllTypes(symbolTable, compilerErrorManager)
            end
        end

        classes = symbolTable:GetClasses()
        repeat while classes:HasNext()
            Class next = classes:Next()
            checker:Add(next)
        end
    end

    action IsCompilationErrorFree returns boolean
        return compilerErrorManager:IsCompilationErrorFree()
    end

    action OutputCompilerErrors
        output "The code did not build correctly. Here is a list of errors:"
        Iterator<CompilerError> errors = compilerErrorManager:GetIterator()
        repeat while errors:HasNext()
            CompilerError error = errors:Next()
            text t = error:GetDisplayName()
            output t
        end
    end

    /*
        This action is called after the parsing phase, returning an array
        of all files were required for building the project.
    */
    action GetAllRequiredFiles returns Array<File>
        Array<File> files

        HashTable<text, File> parsed
        HashTable<text, File> unparsed

        Iterator<Class> classes = symbolTable:GetClasses()
        repeat while classes:HasNext()
            //gather up all the classes on the system and check their
            //use statements for classes we don't know about
            //if there are some, mark them as unparsed
            repeat while classes:HasNext()
                Class clazz = classes:Next()
                File classFile = clazz:GetFile()
                text path = classFile:GetAbsolutePath()
                if not parsed:HasKey(path)
                    parsed:Add(path, clazz:GetFile())
                end
                Iterator<QualifiedName> names = clazz:GetUnresolvedUseStatements()
                ResolveQualifiedNames(names, parsed, unparsed, clazz)

                Iterator<QualifiedName> parents = clazz:GetUnresolvedParents()
                ResolveParents(parents, parsed, unparsed, clazz)

                ResolveBlocks(parsed, unparsed, clazz)
            end

            //make list of any new classes that need to be analyzed
            //that have not previously been parsed. If there are some
            //send them back through the loop
            List<Class> newClasses
            Iterator<File> mustParse = unparsed:GetValueIterator()
            repeat while mustParse:HasNext()
                File next = mustParse:Next()
                Parser listener
                Parse(next, listener)
                parsed:Add(next:GetAbsolutePath(), next)

                Iterator<Class> parsedClasses = listener:GetClassesIterator()
                repeat while parsedClasses:HasNext()
                    Class clazz = parsedClasses:Next()
                    newClasses:Add(clazz)
                    if not symbolTable:HasClass(clazz:GetStaticKey())
                        symbolTable:Add(clazz)
                    end
                end
            end
            classes = newClasses:GetIterator()
            unparsed:Empty()
        end
        return parsed:CopyToValueArray()
    end

    private action ResolveBlocks(HashTable<text, File> parsed,
        HashTable<text, File> unparsed, Class clazz)
        
        Iterator<Action> actions = clazz:GetActions()
        repeat while actions:HasNext()
            Action act = actions:Next()
            //resolve parameters first
            Iterator<Variable> parameters = act:GetParameterIterator()
            repeat while parameters:HasNext()
                Variable parameter = parameters:Next()
                Type type = parameter:GetType()
                ResolveClass(type:GetStaticKey(), clazz, parsed, unparsed)
            end
        end
    end

    /*
        This action handles resolving a class or otherwise scheduling a parse
        from the standard library. If a class is returned, then it has
        already been parsed and is in the symbol table. If the class
        returns is undefined, then either the class does not exist or 
        it is in the standard library and has not yet been parsed. As such,
        returning undefined is not necessarily a compiler error.
    */
    private action ResolveClass(text key, Class clazz, HashTable<text, File> parsed,
        HashTable<text, File> unparsed)
        boolean done = false
        Class c = undefined
        //first check if it's already valid by looking at the symbol
        //table
        c = symbolTable:GetClass(key)

        //if it isn't there, check our use table
        if c = undefined
            c = clazz:GetValidUseName(key)
        end

        //if it isn't there, check the standard library, to 
        //see if there's a file in the right place
        //if there is, mark it for parsing
        if c = undefined
            File file = GetStandardLibraryFile(key, clazz:GetPackageKey())
            if file not= undefined
                text newPath = file:GetAbsolutePath()
                if parsed:HasKey(newPath) //this class has already been parsed
                elseif unparsed:HasKey(newPath) //this class is already scheduled for parsing
                else
                    unparsed:Add(newPath, file)
                end
            else //ok last chance. Check an unresolved use statement to
                 //see if one of these reference the standard library
                 QualifiedName qn = clazz:GetUnresolvedUseStatement(key)
                 if qn not= undefined
                    file = GetStandardLibraryFile(qn:GetStaticKey(), clazz:GetPackageKey())
                    if file not= undefined
                        text newPath = file:GetAbsolutePath()
                        if parsed:HasKey(newPath) //this class has already been parsed
                        elseif unparsed:HasKey(newPath) //this class is already scheduled for parsing
                        else
                            unparsed:Add(newPath, file)
                        end
                    end
                 end
            end
        end
    end

    private action ResolveParents(Iterator<QualifiedName> names, 
            HashTable<text, File> parsed,
            HashTable<text, File> unparsed, Class clazz)
        repeat while names:HasNext()
            QualifiedName qn = names:Next()
            text key = qn:GetStaticKey()
            ResolveClass(key, clazz, parsed, unparsed)
        end
    end

    private action ResolveQualifiedNames(
            Iterator<QualifiedName> names, 
            HashTable<text, File> parsed,
            HashTable<text, File> unparsed, Class clazz)
        repeat while names:HasNext()
            QualifiedName qn = names:Next()
            text key = qn:GetStaticKey()
            ResolveClass(key, clazz, parsed, unparsed)
        end
    end

    action GetStandardLibraryFile(text key, text fromPackage) returns File
        Array<text> values = key:Split("\.")
        text loc = standardLibraryFolder:GetWorkingDirectory()
        text loc2 = standardLibraryFolder:GetAbsolutePath()

        File file
        file:SetWorkingDirectory(loc2)

        if values:GetSize() = 1
            text mySplit = "/" + fromPackage:Replace(".", "/") + "/" + key + ".quorum"
            file:SetPath(mySplit)
            if file:Exists()
                return file
            end
        else
            text location = "/"
            Iterator<text> it = values:GetIterator()
            repeat while it:HasNext()
                text next = it:Next()
                location = location + next

                if it:HasNext()
                    location = location + "/"
                else
                    location = location + ".quorum"
                end
            end

            file:SetPath(location)
            if file:Exists()
                return file
            end
        end
        
        return undefined
    end

    action CompileToJavaScript(Array<File> files)

    end

    action Parse(File file, QuorumSourceListener listener)
        listener:SetSymbolTable(symbolTable)
        listener:SetCompilerErrorManager(compilerErrorManager)
        listener:SetFile(file)
        listener:SetTypeChecker(checker)
        ParseNative(file, listener)
    end

    private system action ParseNative(File file, QuorumSourceListener listener)


    action Parse(text source, QuorumSourceListener listener)
        listener:SetSymbolTable(symbolTable)
        listener:SetCompilerErrorManager(compilerErrorManager)
        listener:SetTypeChecker(checker)
        File file //set a default. It doesn't matter what it is.
        listener:SetFile(file)
        ParseNative(source, listener)
    end

    private system action ParseNative(text source, QuorumSourceListener listener)

    action GetName returns text
        return name
    end

    action GetNameWithExtension returns text
        return name + GetFileExtension()
    end

    action SetName(text name)
        me:name = name
    end

    action GetFileExtension returns text
        if IsWebApplication()
            return ".war"
        else
            return ".jar"
        end
    end

    action GetMain returns File
        return main
    end

    action GetMainClass returns Class
        Class c = symbolTable:GetClassInFile(main:GetAbsolutePath())
        return c
    end

    action SetMain(File file)
        main = file
    end

    action GetVersion returns text
        return "Quorum " + VERSION
    end

    action GetBuildFolder returns File
        if buildFolder = undefined
            File build
            build:SetPath(DEFAULT_BUILD_FOLDER)
            buildFolder = build
        end
        return buildFolder
    end

    action GetRootFolder returns File
        File root
        return root
    end

    action GetStandardLibraryFolder returns File
        if standardLibraryFolder = undefined
            File build
            build:SetPath(DEFAULT_STANDARD_LIBRARY_FOLDER)
            return build
        end
        return standardLibraryFolder
    end

    action SetStandardLibraryFolder(File file)
        standardLibraryFolder = file
    end

    action GetDistributionFile returns File
        File run = GetRunFolder()
        text path = run:GetPath() + "/"
        File newRun
        
        newRun:SetPath(path + GetNameWithExtension())
        return newRun
    end

    action SetBuildFolder(File file)
        buildFolder = file
    end

    action GetRunFolder returns File
        if runFolder = undefined
            File run
            run:SetPath(DEFAULT_RUN_FOLDER)
            runFolder = run
        end
        return runFolder
    end

    action SetRunFolder(File file)
        runFolder = file
    end

    action IsWebApplication returns boolean
        return isWebApplication
    end

    action SetIsWebApplication(boolean web)
        isWebApplication = web
    end
end