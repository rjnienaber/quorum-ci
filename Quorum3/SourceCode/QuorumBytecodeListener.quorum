package Libraries.Language.Compile

use Libraries.Language.Compile.Context.all
use Libraries.Language.Compile.Translate.JavaBytecodeClassWriter
use Libraries.Language.Compile.Translate.JavaBytecodeMethodWriter
use Libraries.Language.Compile.Translate.QuorumBytecodeConverter
use Libraries.Language.Compile.Translate.JavaBytecodeOpcodes
use Libraries.Language.Compile.Symbol.all
use Libraries.Language.Compile.Translate.all

use Libraries.Containers.Array
use Libraries.Containers.List
use Libraries.Containers.HashTable
use Libraries.Containers.Blueprints.Iterator
use Libraries.System.File
use Libraries.Containers.Stack

class QuorumBytecodeListener is QuorumSourceListener 
    QualifiedName packageValue = undefined
    JavaBytecodeClassWriter classWriter = undefined
    JavaBytecodeClassWriter interfaceWriter = undefined
    JavaBytecodeMethodWriter methodWriter = undefined
    JavaBytecodeMethodWriter interfaceMethodWriter = undefined

    QuorumBytecodeConverter converter
    JavaBytecodeOpcodes opcodes
    Action currentAction = undefined
    ActionOpcode currentActionOpcode = undefined
    ClassOpcode currentClassOpcode = undefined
    boolean isInAction = false

    Class currentClass = undefined
    Block currentBlock = undefined
    constant integer ME = 0
    text build = "TestBuild"
    text run = "TestRun"
    constant text QUORUM = "quorum"

    constant text JAVA_THROWABLE = "java/lang/Throwable"
    constant text JAVA_OBJECT = "java/lang/Object"
    constant text QUORUM_ERROR = "quorum/Libraries/Language/Errors/Error"
    boolean isNormalAction = false
    boolean isSystemAction = false
    boolean isBluePrintAction = false
    boolean isNextVariableReferenceMe = false
    Stack<QuorumOpcode> opcodeStack
    Stack<ConditionalOpcode> ifStack
    Stack<LoopOpcode> loopStack
    File buildFile = undefined
    File buildInterfaceFile = undefined
    BlockOpcode currentBlockOpcode = undefined
    Stack<BlockOpcode> poppedBlockOpcodes
    Stack<BlockOpcode> currentBlocks
    Stack<integer> blockPositionStack
    Stack<ActionExpressionListContext> actionCallParameterStack
    HashTable<integer, Array<ActionCallOpcode>> actionCallStacks
    integer currentActionStack = 0
    integer loopCounter = 0
    integer ifCount = 0

    action GetClassOpcode returns ClassOpcode
        return currentClassOpcode
    end

    action GetBuildFile returns File
        return buildFile
    end

    action GetBuildInterfaceFile returns File
        return buildInterfaceFile
    end
    
    private action SetNormalAction 
        isNormalAction = true
        isSystemAction = false
        isBluePrintAction = false
    end

    private action SetSystemAction 
        isNormalAction = false
        isSystemAction = true
        isBluePrintAction = false
    end

    private action SetBlueprintAction 
        isNormalAction = false
        isSystemAction = false
        isBluePrintAction = true
    end

    private action ClearActionState
        isNormalAction = false
        isSystemAction = false
        isBluePrintAction = false
    end

    action ExitPackageRule(PackageContext context) 
        packageValue = context:name
    end

    action EnterFullClassDeclaration(FullClassDeclarationContext context) 
        AddClass(context:className)
    end

    action AddClass(text className) 
        JavaBytecodeClassWriter newClassWriter
        JavaBytecodeClassWriter newIinterfaceWriter

        classWriter = newClassWriter
        interfaceWriter = newIinterfaceWriter
        ClassOpcode classOp
        currentClassOpcode = classOp

        text name = className
        SymbolTable table = me:GetSymbolTable()
        
        text staticKey = ""
        if packageValue = undefined
            QualifiedName default
            packageValue = default
        end
        staticKey = packageValue:GetClassStaticKey(name)
        currentClass = table:GetClass(staticKey)
        currentClassOpcode:SetClass(currentClass)
        currentClassOpcode:SetName(name)
        currentClassOpcode:SetStaticKey(staticKey)
        currentClassOpcode:SetBuildPath(build)
        currentClassOpcode:SetRunPath(run)
        currentClassOpcode:SetPackage(packageValue)
        currentClassOpcode:SetClassWriter(classWriter)
        currentClassOpcode:SetInterfaceWriter(interfaceWriter)
    end

    action EnterNoActionsNoClass(NoActionsNoClassContext context) 
        File file = GetFile()
        text name = file:GetFileName()
        text extension = file:GetFileExtension()
        integer length = extension:GetSize()
        name = name:GetSubtext(0, name:GetSize() - length - 1)
        AddClass(name)


        if currentClass not= undefined
            //get the method name
            Array<Variable> vars
            Iterator<Variable> paramIt = vars:GetIterator()
            text key = currentClass:ResolveActionKey("Main", paramIt,
                GetSymbolTable(), GetCompilerErrorManager())

            Action method = currentClass:GetAction(key)
            currentAction = method
            ActionOpcode actionOpcode
            currentActionOpcode = actionOpcode
            currentActionOpcode:SetAction(method)
            currentActionOpcode:SetClass(currentClass)

            boolean isMain = method:IsMain()
            text null = undefined
            text actionName = method:GetName()
            text params = method:ConvertActionToBytecodeParameterInterfaceSignature()
            methodWriter = 
                classWriter:VisitMethod(opcodes:GetPublic(), 
                actionName, params, null, undefined)
            currentActionOpcode:SetMethodWriter(methodWriter)
            currentClassOpcode:Add(currentActionOpcode)


            BlockContext b
            Location loc = b:GetLocation()
            loc:SetLocation(context:GetLocation())
            EnterBlock(b)
        end
    end

    action ExitNoActionsNoClass(NoActionsNoClassContext context) 
        BlockContext b
        Location loc = b:GetLocation()
        loc:SetLocation(context:GetLocation())
        ExitBlock(b)


        ActionContext actContext
        loc = actContext:GetLocation()
        loc:SetLocation(context:GetLocation())
        ExitAction(actContext)
        ExitClass()
    end

    action ExitClass
        if currentClass not= undefined
            CompilerErrorManager manager = GetCompilerErrorManager()
            if manager:IsCompilationErrorFree()
                currentClass:ResolveFrames()
            end
        end
    end

    action ExitFullClassDeclaration(FullClassDeclarationContext context) 
        ExitClass()
    end

    action ExitActionHeader(ActionContext context)
        if currentClass not= undefined
            //get the method name
            List<Variable> list = context:parameters
            Iterator<Variable> paramIt = list:GetIterator()
            text key = currentClass:ResolveActionKey(context:actionName, paramIt,
                GetSymbolTable(), GetCompilerErrorManager())

            Action method = currentClass:GetAction(key)
            currentAction = method
            ActionOpcode actionOpcode
            currentActionOpcode = actionOpcode
            currentActionOpcode:SetAction(method)
            currentActionOpcode:SetClass(currentClass)

            boolean isMain = method:IsMain()
            text null = undefined
            text name = method:GetName()
            text params = method:ConvertActionToBytecodeParameterInterfaceSignature()
            methodWriter = 
                classWriter:VisitMethod(opcodes:GetPublic(), 
                name, params, null, undefined)
            currentActionOpcode:SetMethodWriter(methodWriter)
            currentClassOpcode:Add(currentActionOpcode)
        end
    end

    action EnterConstructor(ConstructorContext context) 
        currentAction = currentClass:GetConstructor()
    end

    action ExitConstructor(ConstructorContext context) 
        currentAction = undefined
    end

    action EnterAction(ActionContext context) 
        SetNormalAction()
        isInAction = true
    end

    action ExitAction(ActionContext context) 
        ClearActionState()
        
        if currentActionOpcode not= undefined
            if not poppedBlockOpcodes:IsEmpty()
                currentActionOpcode:Add(poppedBlockOpcodes:Pop())
            end

            //if there are opcodes on the opcode stack for a return, pop them
            //there should never be more than 1, so throw an error if there is
            remaining = opcodeStack:GetSize()
            if remaining not= 0
                if remaining not= 1
                    //alert("Compiler Bug: Cannot have more than 1 remaining opcode on the opcode stack at the end of an action.")
                else 
                    QuorumOpcode op = opcodeStack:Pop()
                    currentActionOpcode:Add(op)
                end
            end
        end
        isInAction = false
    end

    action ExitOutputStatement(OutputContext context)
        QuorumOpcode op = opcodeStack:Pop()
        OutputOpcode out
        out:SetOpcode(op)
        out:SetMethodWriter(methodWriter)
        currentBlockOpcode:Add(out)
    end

    action EnterBlock(BlockContext context)
        if currentBlock = undefined
            currentBlock = currentAction:GetBlock()
            blockPositionStack:Push(0)
        else 
            integer value = blockPositionStack:Pop()
            if value < currentBlock:GetSubBlockSize()
                currentBlock = currentBlock:GetBlock(value)
                blockPositionStack:Push(value + 1)
                //now push on a 0 for the new block
                blockPositionStack:Push(0)
            else 
                alert("Compiler Bug in EnterBlock of the Type Check Listener.")
            end
        end

        if currentBlockOpcode = undefined
            BlockOpcode block
            currentBlockOpcode = block
            currentBlocks:Push(block)
        else
            BlockOpcode block
            block:SetParentBlock(currentBlockOpcode)
            currentBlockOpcode = block
            currentBlocks:Push(block)
        end
    end
    
    action ExitBlock(BlockContext context)
        if currentBlock not= undefined
            currentBlock = currentBlock:GetParentBlock() //may be undefined
            blockPositionStack:Pop()
        end

        if currentBlockOpcode not= undefined
            BlockOpcode op = currentBlocks:Pop()
            poppedBlockOpcodes:Push(op)
            if currentBlocks:IsEmpty()
                currentBlockOpcode = undefined
            else
                currentBlockOpcode = currentBlocks:Peek()
            end
        end
    end

    action EnterLoopStatement(LoopContext context) 
        LoopOpcode loop
        loop:SetMethodWriter(methodWriter)
        if context:isUntil
            loop:SetUntil()
        elseif context:isTimes
            loop:SetTimes()
        else
            loop:SetWhile()
        end

        if context:isTimes
            constant text LOOP_NAME = "Loopy"
            Variable variable = undefined
            variable = currentBlock:GetVariable(loopCounter + LOOP_NAME)
            loop:SetVariable(variable)
        end

        loopStack:Push(loop)
        loopCounter = loopCounter + 1
    end

    action ExitLoopStatement(LoopContext context) 
        LoopOpcode loop = loopStack:Pop()
        QuorumOpcode qop = opcodeStack:Pop()
        qop:SetIsIfExpression(true)
        

        loop:SetExpression(qop)
        BlockOpcode recentlyPopped = poppedBlockOpcodes:Pop()
        loop:SetBlock(recentlyPopped)
        
        currentBlockOpcode:Add(loop)
    end

    action EnterIfStatement(IfContext context) 
        ConditionalOpcode conditional
        conditional:SetIfLabelInteger(ifCount)
        conditional:SetMethodWriter(methodWriter)

        ifCount = ifCount + 1
        ifStack:Push(conditional)
    end
    

    action ExitIfStatement(IfContext context) 
        ConditionalOpcode conditional = ifStack:Pop()
        QuorumOpcode qop = opcodeStack:Pop()
        qop:SetIsIfExpression(true)
        conditional:SetExpression(qop)
        BlockOpcode recentlyPopped = poppedBlockOpcodes:Pop()
        conditional:SetBlock(recentlyPopped)
        
        currentBlockOpcode:Add(conditional)
    end

    action EnterElseIfStatement(IfContext context) end
    action ExitElseIfStatement(IfContext context) 
        ConditionalOpcode conditional = ifStack:Peek()
        QuorumOpcode qop = opcodeStack:Pop()
        qop:SetIsIfExpression(true)
        BlockOpcode recentlyPopped = poppedBlockOpcodes:Pop()
        conditional:AddElseIf(qop, recentlyPopped)
    end

    action EnterElseStatement(IfContext context) end
    action ExitElseStatement(IfContext context) 
        ConditionalOpcode conditional = ifStack:Peek()
        BlockOpcode recentlyPopped = poppedBlockOpcodes:Pop()
        conditional:SetElseBlock(recentlyPopped)
    end

    action ExitObjectAssignment(ObjectAssignmentContext context) 
        text name = context:name
        text object = context:object
        QualifiedName theParent = context:parentName
        
        Variable variable = undefined
        Variable field = undefined
        Class clazz = undefined
        if not isInAction
            variable = currentClass:GetVariable(object)
        else 
            variable = currentBlock:GetVariable(object)
        end

        //this is not a call to a parent field.
        if theParent not= undefined
            //now get the field from that object

        else
            if variable not= undefined //if it is, it should have been caught in a previous phase
                Type type = variable:GetType()
                if not type:IsPrimitive() //if it is, again previous phase
                    text staticKey = type:GetStaticKey()
                    SymbolTable table = GetSymbolTable()
                    clazz = table:GetClass(staticKey)
                    
                    //get a field. It has to be there, otherwise a previous phase would have complained
                    field = clazz:GetVariable(name)
                end
            end

        end

        right = opcodeStack:Pop()


        Operation assign
        assign:SetOperation(assign:EQUALS)

        TypeChecker checker = GetTypeChecker()
        TypeCheckResult result = checker:Check(field:GetType(), right:GetType(), undefined, true) 

        integer location = variable:GetBytecodeLocation()
        Type value = result:result
        QuorumOpcode qop = result:GetQuorumOpcode()
        AssignmentOpcode assignment = cast(AssignmentOpcode, result:GetQuorumOpcode())
        assignment:SetClass(currentClass)
        assignment:SetRightHandSide(right)
        assignment:SetType(value)
        assignment:SetMethodWriter(methodWriter)
        //assignment:SetBytecodeLocation(location)
        assignment:SetVariable(variable)
        assignment:SetField(field)
        assignment:SetIsObjectField(true)

        if isInAction
            currentBlockOpcode:Add(assignment)
        else //add the opcode to the field calculator
            currentClassOpcode:AddField(assignment)
        end
    end

    action ExitNormalAssignment(NormalAssignmentContext context) 
        text name = context:name
        Variable variable = undefined
        if not isInAction
            variable = currentClass:GetVariable(name)
        else 
            variable = currentBlock:GetVariable(name)
        end

        Type left = variable:GetType()
        QuorumOpcode right = undefined
        if context:hasRightHandSide = false
            Type typeOriginal = context:leftHandSide
            if typeOriginal:IsPrimitive()
                Type type = typeOriginal:Copy()
                type:SetIsConstant(true)
                QuorumConstant const
                const:SetMethodWriter(methodWriter)
                const:SetType(type)
                if type:IsInteger()
                    type:SetIntegerConstant(0)
                    const:integerValue = 0
                elseif type:IsBoolean()
                    type:SetBooleanConstant(false)
                    const:booleanValue = false
                elseif type:IsNumber()
                    type:SetNumberConstant(0.0)
                    const:numberValue = 0.0
                elseif type:IsText()
                    type:SetTextConstant("")
                    const:textValue = ""
                end
                opcodeStack:Push(const)
            else 
                SymbolTable table = me:GetSymbolTable()
                Class clazz = table:GetClass(left:GetStaticKey())
                CreateObjectOpcode opcode
                opcode:SetMethodWriter(methodWriter)
                opcode:SetClass(clazz)
                opcode:SetVariable(variable)
                //opcode:SetBytecodeLocation(variable:GetBytecodeLocation())

                if isInAction
                    currentBlockOpcode:Add(opcode)
                    return now
                else //add the opcode to the field calculator
                    currentClassOpcode:AddField(opcode)
                    return now
                end
                
            end
        end

        right = opcodeStack:Pop()


        Operation assign
        assign:SetOperation(assign:EQUALS)

        TypeChecker checker = GetTypeChecker()
        TypeCheckResult result = checker:Check(left, right:GetType(), undefined, true) 
        CompilerError error = result:GetCompilerError(context:GetLocation())

        if error not= undefined
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        integer location = variable:GetBytecodeLocation()
        Type value = result:result
        QuorumOpcode qop = result:GetQuorumOpcode()
        AssignmentOpcode assignment = cast(AssignmentOpcode, result:GetQuorumOpcode())
        assignment:SetClass(currentClass)
        assignment:SetRightHandSide(right)
        assignment:SetType(value)
        assignment:SetMethodWriter(methodWriter)
        //assignment:SetBytecodeLocation(location)
        assignment:SetVariable(variable)

        if isInAction
            currentBlockOpcode:Add(assignment)
        else //add the opcode to the field calculator
            currentClassOpcode:AddField(assignment)
        end
    end

    action ExitNoTypeAssignment(NoTypeAssignmentContext context) 
        text name = context:name
        Variable variable = undefined
        TypeChecker checker = GetTypeChecker()

        if context:hasMe or context:isField
            variable = currentClass:GetVariable(name)
            //write the field
        else 
            variable = currentBlock:GetVariable(name)
            Type left = variable:GetType()

            QuorumOpcode right = opcodeStack:Pop()
            if left = undefined //if the type is undefined, it might be possible to infer it
                InferenceResult infer = checker:CanInfer(right)
                if infer:canInfer //hey awesome, that was easy!
                    Type rightType = right:GetType()
                    rightType = rightType:Copy()
                    left = rightType
                    variable:SetType(left)
                else
                    CompilerError error
                    error:SetLocation(variable)
                    CompilerErrorType errorType
                    errorType:SetCurrentType(errorType:VARIABLE_INFERENCE)
                    error:SetCompilerErrorType(errorType)
                    Type otherType = right:GetType()
                    error:SetErrorMessage("I will not infer the type of the " + 
                        "right hand side of this expression automatically. To " +
                        " fix this, change the declaration to " + otherType:GetStaticKeyWithGenerics() + 
                        " " + variable:GetName() + ".")
                    CompilerErrorManager manager = GetCompilerErrorManager()
                    manager:Add(error)
                    return now
                end
            end

            Operation assign
            assign:SetOperation(assign:EQUALS)

            
            TypeCheckResult result = checker:Check(left, right:GetType(), undefined, true) 

            integer location = variable:GetBytecodeLocation()
            Type value = result:result
            AssignmentOpcode assignment = cast(AssignmentOpcode, result:GetQuorumOpcode())
            assignment:SetClass(currentClass)
            assignment:SetRightHandSide(right)
            assignment:SetType(value)
            assignment:SetMethodWriter(methodWriter)
            //assignment:SetBytecodeLocation(location)
            assignment:SetVariable(variable)
            currentBlockOpcode:Add(assignment)
        end
    end
    
    action EnterVariableSoloFunctionCall(VariableFunctionCallContext context) 
        isNextVariableReferenceMe = context:hasMe
        Array<ActionCallOpcode> stack
        actionCallStacks:Add(me:currentActionStack, stack)
        currentActionStack = currentActionStack + 1


        ActionCallOpcode actionCall
        actionCall:SetMethodWriter(methodWriter)
        actionCall:SetIsActionCall(true)
        stack:Add(actionCall)
    end

    action ExitVariableSoloFunctionCall(VariableFunctionCallContext context)
        Array<ActionCallOpcode> actionArray = actionCallStacks:GetValue(0)
        ActionCallOpcode actionCall = actionArray:Get(0)
        actionCall:SetPushOnMe(true)
        ActionExpressionListContext params =  actionCallParameterStack:Pop()
        size = params:size

        Array<QuorumOpcode> parametersBackward
        repeat size times
            QuorumOpcode param = opcodeStack:Pop()
            parametersBackward:Add(param)
        end

        Array<Type> parameters
        Array<QuorumOpcode> parameterOpcodes
        i = size - 1
        repeat size times
            QuorumOpcode op = parametersBackward:Get(i)
            parameters:Add(op:GetType())
            parameterOpcodes:Add(op)
            i = i - 1
        end

        actionCall:SetParameters(parameterOpcodes)

        ActionCall call
        call:actualParameters = parameters
        call:name = context:name
        call:checker = GetTypeChecker()
        call:table = GetSymbolTable()
        ActionCallResolution resolved = currentClass:ResolveAction(call)

        if resolved not= undefined and resolved:isResolved
            actionCall:SetActionCallResolution(resolved)
            actionCall:SetIsActionCall(true)

            actionCall:SetActionCallResolution(resolved)
        else
            CompilerError error = resolved:error 
            if error not= undefined
                CompilerErrorManager manager = GetCompilerErrorManager()
                manager:Add(error)
            end
        end

        isNextVariableReferenceMe = false
        Array<ActionCallOpcode> stack = actionCallStacks:RemoveKey(me:currentActionStack - 1)
        currentActionStack = currentActionStack - 1

        ChainedActionCallOpcode ops
        ops:SetIsSoloCall(true)
        Iterator<ActionCallOpcode> it = stack:GetIterator()
        repeat while it:HasNext()
            ActionCallOpcode op = it:Next()
            ops:Add(op)
        end

        currentBlockOpcode:Add(ops)
    end

    action EnterParentVariableSoloFunctionCall(ParentVariableFunctionCallContext context) end
    action ExitParentVariableSoloFunctionCall(ParentVariableFunctionCallContext context) end

    action EnterVariableFunctionCall(VariableFunctionCallContext context) 
        isNextVariableReferenceMe = context:hasMe
        Array<ActionCallOpcode> stack
        actionCallStacks:Add(me:currentActionStack, stack)
        currentActionStack = currentActionStack + 1
    end

    action ExitVariableFunctionCall(VariableFunctionCallContext context) 
        isNextVariableReferenceMe = false
        Array<ActionCallOpcode> stack = actionCallStacks:RemoveKey(me:currentActionStack - 1)
        currentActionStack = currentActionStack - 1

        ChainedActionCallOpcode ops
        Iterator<ActionCallOpcode> it = stack:GetIterator()
        repeat while it:HasNext()
            ActionCallOpcode op = it:Next()
            ops:Add(op)
        end

        opcodeStack:Push(ops)
    end

    action EnterParentVariableFunctionCall(ParentVariableFunctionCallContext context)
        a =5
    end
    action ExitParentVariableFunctionCall(ParentVariableFunctionCallContext context)
        a =5
    end

    action ExitActionExpressionList(ActionExpressionListContext context) 
        actionCallParameterStack:Push(context)
    end

    action ExitActionCall(ActionCallContext context)
        ActionCallOpcode actionCall
        actionCall:SetMethodWriter(methodWriter)

        if context:isActionCall //push the "this" pointer
            actionCall:SetIsActionCall(true)
            ActionExpressionListContext params =  actionCallParameterStack:Pop()
            size = params:size

            Array<ActionCallOpcode> stack = actionCallStacks:GetValue(currentActionStack - 1)

            if stack:IsEmpty() //this is a solo call, push on this
                actionCall:SetPushOnMe(true)
            end

            Array<QuorumOpcode> parametersBackward
            repeat size times
                QuorumOpcode param = opcodeStack:Pop()
                parametersBackward:Add(param)
            end

            Array<Type> parameters
            Array<QuorumOpcode> parameterOpcodes
            i = size - 1
            repeat size times
                QuorumOpcode op = parametersBackward:Get(i)
                parameters:Add(op:GetType())
                parameterOpcodes:Add(op)
                i = i - 1
            end

            actionCall:SetParameters(parameterOpcodes)
            ActionCall call
            call:actualParameters = parameters
            call:name = context:name
            call:checker = GetTypeChecker()
            call:table = GetSymbolTable()
            ActionCallResolution resolved = currentClass:ResolveAction(call)

            if resolved not= undefined and resolved:isResolved
                actionCall:SetActionCallResolution(resolved)
                actionCall:SetIsActionCall(true)

                actionCall:SetActionCallResolution(resolved)
            else
                CompilerError error = resolved:error 
                if error not= undefined
                    CompilerErrorManager manager = GetCompilerErrorManager()
                    manager:Add(error)
                end
            end

            i = i
        else //push the variable
            actionCall:SetIsActionCall(false)
            name = context:name
            Variable variable = undefined

            Array<ActionCallOpcode> stack = actionCallStacks:GetValue(currentActionStack - 1)

            if stack:IsEmpty() //this is a solo call, push on this
                if isNextVariableReferenceMe
                    variable = currentClass:GetVariable(name)
                else 
                    variable = currentBlock:GetVariable(name)
                    isNextVariableReferenceMe = false
                end

                if variable not= undefined
                    Type type = variable:GetType()
                    actionCall:SetType(type)
                    actionCall:SetField(variable)
                    actionCall:SetFieldHolder(currentClass)
                    //actionCall:SetBytecodeLocation(variable:GetBytecodeLocation())
                end
            else //get the most recent type off the stack
                ActionCallOpcode code = stack:Get(stack:GetSize() - 1)
                Type type = code:GetType()
                if not type:IsPrimitive() //if it is, again previous phase will catch this
                    text staticKey = type:GetStaticKey()
                    SymbolTable table = GetSymbolTable()
                    clazz = table:GetClass(staticKey)
                    
                    //get a field. It has to be there, otherwise a previous phase would have complained
                    field = clazz:GetVariable(name)
                    if field not= undefined
                        Type fieldType = field:GetType()
                        actionCall:SetType(fieldType)
                        //tell the action call opcode this is a field and of whom
                        //actionCall:SetBytecodeLocation(field:GetBytecodeLocation())
                        actionCall:SetIsField(true)
                        actionCall:SetField(field)
                        actionCall:SetFieldHolder(clazz)
                    end
                end
            end
            
            
            

            
        end

        Array<ActionCallOpcode> stack = actionCallStacks:GetValue(currentActionStack - 1)
        stack:Add(actionCall)
        //opcodeStack:Push(actionCall)
    end

    action ExitReturnStatement(ReturnContext context) 
        Type type = currentAction:GetReturnType()
        if not type:IsVoid() //if this is not a void method, handle the return
            QuorumOpcode right = opcodeStack:Pop()

            Operation returnOp
            returnOp:SetOperation(returnOp:RETURN)

            TypeChecker checker = GetTypeChecker()
            TypeCheckResult result = checker:Check(type, right:GetType(), returnOp) 
            CompilerError error = result:GetCompilerError(context:GetLocation())
            if error not= undefined
                CompilerErrorManager manager = GetCompilerErrorManager()
                manager:Add(error)
                return now
            end

            ReturnOpcode opcode = cast(ReturnOpcode, result:GetQuorumOpcode())
            opcode:SetReturnValue(right)
            opcode:SetMethodWriter(methodWriter)
            currentBlockOpcode:Add(opcode)
        else //if it is a void method, just do a normal return, but don't pop off the opcode stack
            ReturnOpcode opcode
            opcode:SetType(type)
            opcode:SetMethodWriter(methodWriter)
            currentBlockOpcode:Add(opcode)
        end
    end

    action ExitInequality(InequalityContext context) 
        TypeChecker checker = GetTypeChecker()
        QuorumOpcode right = opcodeStack:Pop()
        QuorumOpcode left = opcodeStack:Pop()
        Operation add
        if context:isGreater
            add:SetOperation(add:GREATER)
        elseif context:isGreaterEquals
            add:SetOperation(add:GREATER_EQUALS)
        elseif context:isLess
            add:SetOperation(add:LESS)
        elseif context:isLessEquals
            add:SetOperation(add:LESS_EQUALS)
        end
        
        TypeCheckResult result = checker:Check(left:GetType(), right:GetType(), add)
        CompilerError error = result:GetCompilerError(context:GetLocation())
        if error not= undefined
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        Type value = result:result
        ComparisonOpcode compare = cast(ComparisonOpcode, result:GetQuorumOpcode())
        compare:SetMethodWriter(methodWriter)
        compare:SetType(value)
        compare:SetLeftOpcode(left)
        compare:SetRightOpcode(right)
        opcodeStack:Push(compare)
    end

    action ExitEquals (EqualsContext context)
        TypeChecker checker = GetTypeChecker()
        QuorumOpcode right = opcodeStack:Pop()
        QuorumOpcode left = opcodeStack:Pop()
        Operation add
        if context:equalsTo
            add:SetOperation(add:EQUALS)
        else
            add:SetOperation(add:NOT_EQUALS)
        end
        
        TypeCheckResult result = checker:Check(left:GetType(), right:GetType(), add)
        CompilerError error = result:GetCompilerError(context:GetLocation())
        if error not= undefined
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        Type value = result:result
        ComparisonOpcode compare = cast(ComparisonOpcode, result:GetQuorumOpcode())
        compare:SetMethodWriter(methodWriter)
        compare:SetType(value)
        compare:SetLeftOpcode(left)
        compare:SetRightOpcode(right)
        opcodeStack:Push(compare)
    end

    action EnterAnd(AndOrContext context) end
    action ExitAnd(AndOrContext context) 
        DoAndOr(context)
    end

    action DoAndOr(AndOrContext context)
        TypeChecker checker = GetTypeChecker()
        QuorumOpcode right = opcodeStack:Pop()
        QuorumOpcode left = opcodeStack:Pop()
        Operation op
        if context:isAnd
            op:SetOperation(op:AND)
        else 
            op:SetOperation(op:OR)
        end

        TypeCheckResult result = checker:Check(left:GetType(), right:GetType(), op)
        CompilerError error = result:GetCompilerError(context:GetLocation())
        if error not= undefined
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        Type value = result:result
        BinaryAndOrOpcode binary
        binary:isAnd = context:isAnd
        binary:methodWriter = methodWriter
        binary:SetType(value)
        binary:SetOperation(op)
        binary:left = left
        binary:right = right

        if left is BinaryAndOrOpcode
            BinaryAndOrOpcode theAnd = cast(BinaryAndOrOpcode, left)
            theAnd:hasParent = true
            theAnd:opcodeParent = binary
            theAnd:isOnLeft = true
        end

        if right is BinaryAndOrOpcode
            BinaryAndOrOpcode theAnd = cast(BinaryAndOrOpcode, right)
            theAnd:hasParent = true
            theAnd:opcodeParent = binary
            theAnd:isOnLeft = false
        end
        opcodeStack:Push(binary)
    end

    action EnterOr(AndOrContext context) end
    action ExitOr(AndOrContext context)
        DoAndOr(context)
    end

    action ExitMultiplication(MultiplicationContext context) 
        TypeChecker checker = GetTypeChecker()
        QuorumOpcode right = opcodeStack:Pop()
        QuorumOpcode left = opcodeStack:Pop()
        Operation op
        if context:isDivide
            op:SetOperation(op:DIVIDE)
        elseif context:isMultiply
            op:SetOperation(op:TIMES)
        else
            op:SetOperation(op:MODULUS)
        end

        TypeCheckResult result = checker:Check(left:GetType(), right:GetType(), op)
        CompilerError error = result:GetCompilerError(context:GetLocation())
        if error not= undefined
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        Type value = result:result
        BinaryOpcode binary = cast(BinaryOpcode, result:GetQuorumOpcode())
        binary:SetMethodWriter(methodWriter)
        binary:SetType(value)
        binary:SetLeftOpcode(left)
        binary:SetRightOpcode(right)
        opcodeStack:Push(binary)
    end

    action ExitAddition(AdditionContext addition) 
        TypeChecker checker = GetTypeChecker()
        QuorumOpcode right = opcodeStack:Pop()
        QuorumOpcode left = opcodeStack:Pop()
        Operation add
        if addition:isPlus
            add:SetOperation(add:PLUS)
        else
            add:SetOperation(add:MINUS)
        end

        TypeCheckResult result = checker:Check(left:GetType(), right:GetType(), add)
        CompilerError error = result:GetCompilerError(addition:GetLocation())
        if error not= undefined
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        Type value = result:result
        BinaryOpcode binary = cast(BinaryOpcode, result:GetQuorumOpcode())
        binary:SetMethodWriter(methodWriter)
        binary:SetType(value)
        binary:SetLeftOpcode(left)
        binary:SetRightOpcode(right)
        opcodeStack:Push(binary)
    end

    action ExitMinus(UnaryMinusContext context) 
        TypeChecker checker = GetTypeChecker()
        QuorumOpcode left = opcodeStack:Pop()

        Operation notOp
        notOp:SetOperation(notOp:MINUS)
        TypeCheckResult result = checker:Check(left:GetType(), notOp) 
        CompilerError error = result:GetCompilerError(context:GetLocation())
        if error not= undefined
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        Type value = result:result
        NegateUnaryOpcode binary = cast(NegateUnaryOpcode, result:GetQuorumOpcode())
        binary:SetMethodWriter(methodWriter)
        binary:SetType(value)
        binary:SetOpcode(left)
        opcodeStack:Push(binary)
    end

    action ExitNot(NotContext context) 
        TypeChecker checker = GetTypeChecker()
        QuorumOpcode left = opcodeStack:Pop()

        Operation notOp
        notOp:SetOperation(notOp:NOT)
        TypeCheckResult result = checker:Check(left:GetType(), notOp) 
        CompilerError error = result:GetCompilerError(context:GetLocation())
        if error not= undefined
            CompilerErrorManager manager = GetCompilerErrorManager()
            manager:Add(error)
            return now
        end

        Type value = result:result
        FlipBooleanOpcode binary = cast(FlipBooleanOpcode, result:GetQuorumOpcode())
        binary:SetMethodWriter(methodWriter)
        binary:SetType(value)
        binary:SetOpcode(left)
        opcodeStack:Push(binary)
    end

    action ExitUndefined(UndefinedContext context) 
        Type type
        type:SetIsConstant(true)
        type:SetToUndefined()

        QuorumConstant const
        const:SetMethodWriter(methodWriter)
        const:SetType(type)
        opcodeStack:Push(const)
    end

    action ExitInteger(IntegerContext context) 
        Type type
        type:SetIsConstant(true)
        type:SetIntegerConstant(context:value)

        QuorumConstant const
        const:SetMethodWriter(methodWriter)
        const:SetType(type)
        const:integerValue = context:value
        opcodeStack:Push(const)
    end
    
    action ExitText(TextContext context) 
        Type type
        type:SetIsConstant(true)
        type:SetTextConstant(context:value)

        QuorumConstant const
        const:SetMethodWriter(methodWriter)
        const:SetType(type)
        const:textValue = context:value
        opcodeStack:Push(const)
    end

    action ExitBoolean(BooleanContext context) 
        Type type
        type:SetIsConstant(true)
        type:SetBooleanConstant(context:value)

        QuorumConstant const
        const:SetMethodWriter(methodWriter)
        const:SetType(type)
        const:booleanValue = context:value
        opcodeStack:Push(const)
    end

    action ExitNumber(NumberContext context) 
        Type type
        type:SetIsConstant(true)
        type:SetNumberConstant(context:value)

        QuorumConstant const
        const:SetMethodWriter(methodWriter)
        const:SetType(type)
        const:numberValue = context:value
        opcodeStack:Push(const)
    end
end