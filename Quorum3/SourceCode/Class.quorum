package Libraries.Language.Compile.Symbol

use Libraries.Language.Compile.QualifiedName
use Libraries.Language.Compile.CompilerError
use Libraries.Language.Compile.CompilerErrorManager
use Libraries.Language.Compile.CompilerErrorType
use Libraries.Containers.HashTable
use Libraries.Language.Compile.Location
use Libraries.Containers.Blueprints.Iterator
use Libraries.Containers.Array
use Libraries.System.File
use Libraries.Language.Compile.Translate.QuorumOpcode

class Class is Symbol
    QualifiedName packageName
    HashTable<text, Action> actions
    HashTable<text, Action> virtualActions
    HashTable<text, Action> parentActions
    HashTable<text, Array<Type>> parentGenerics
    HashTable<text, HashTable<integer, integer>> parentGenericMap = undefined
    HashTable<text, Variable> fields
    Action constructor = undefined
    boolean hasMain = false
    HashTable<text, QualifiedName> unresolvedUseStatements
    Array<QualifiedName> unresolvedParents
    HashTable<text, Class> validUses
    HashTable<text, Class> validUsesFullyQualified
    HashTable<text, Class> parents
    Array<Class> directParents
    Array<text> generics
    HashTable<text, integer> genericHash
    boolean areParentsResolved = false
    boolean isResolvingParents = false
    boolean isTypeResolved = false
    File file = undefined
    boolean hasSystemAction = false
    constant text LIBRARIES_LANGUAGE_OBJECT = "Libraries.Language.Object"
    constant text LIBRARIES_LANGUAGE_ERRORS_ERROR = "Libraries.Language.Errors.Error"
    boolean isMainClass = false
    Array<Array<Class>> resolvedParentLevels

    on create
        QualifiedName object
        object:Add("Libraries")
        object:Add("Language")
        object:Add("Object")

        AddUnresolvedUseStatement(object)

        QualifiedName textObject
        textObject:Add("Libraries")
        textObject:Add("Language")
        textObject:Add("Types")
        textObject:Add("Text")

        AddUnresolvedUseStatement(textObject)

        QualifiedName booleanObject
        booleanObject:Add("Libraries")
        booleanObject:Add("Language")
        booleanObject:Add("Types")
        booleanObject:Add("Boolean")

        AddUnresolvedUseStatement(booleanObject)

        QualifiedName integerObject
        integerObject:Add("Libraries")
        integerObject:Add("Language")
        integerObject:Add("Types")
        integerObject:Add("Integer")

        AddUnresolvedUseStatement(integerObject)

        QualifiedName numberObject
        numberObject:Add("Libraries")
        numberObject:Add("Language")
        numberObject:Add("Types")
        numberObject:Add("Number")

        AddUnresolvedUseStatement(numberObject)

        QualifiedName errorObject
        errorObject:Add("Libraries")
        errorObject:Add("Language")
        errorObject:Add("Errors")
        errorObject:Add("Error")

        AddUnresolvedUseStatement(errorObject)
    end

    action HasParentGenerics(text key) returns boolean
        return parentGenerics:HasKey(key)
    end

    action GetParentGenerics(text key) returns Array<Type>
        return parentGenerics:GetValue(key)
    end

    action SetParentGenerics(text key, Array<Type> types)
        parentGenerics:Set(key, types)
    end
        
    action IsProgramStartingClass returns boolean
        return isMainClass
    end

    action SetIsProgramStartingClass(boolean main)
        isMainClass = main
    end

    action AddGeneric(text name)
        generics:Add(name)
        genericHash:Add(name, generics:GetSize() - 1)
    end

    action GetNumberGenerics returns integer
        return generics:GetSize()
    end

    action GetGeneric(integer location) returns text
        return generics:Get(location)
    end

    /*
        This action determines whether a generic of a particular name 
        exists in this class.
    */
    action HasGeneric(text name) returns boolean
        return genericHash:HasKey(name)
    end

    /*
        This action digs through the generics and, if it finds one
        by this name, returns its index. If no generic by this name
        is found, then this returns -1.
    */
    action GetIndexOfGeneric(text name) returns integer
        if HasGeneric(name)
            return genericHash:GetValue(name)
        else
            return -1
        end
    end

    action ConvertStaticKeyToParentActionName returns text
        key = GetStaticKey()
        result = "$parent$" + key:Replace(".", "$")
        return result
    end

    /*
        This action looks at all actions listed in this class's declared
        action table, in addition to those actions declared in parents,
        and fills up a new virtual action table with all actions combined.
        If this action has an error, it is created and sent to the 
        compiler error manager passed in.
    */
    action ComputeVirtualActionTable (CompilerErrorManager errors)
        Iterator<Action> declaredActions = GetActions()
        repeat while declaredActions:HasNext()
            Action act = declaredActions:Next()
            virtualActions:Add(act:GetStaticKey(), act)
        end

        HashTable<text, Class> computed
        //now dig through all parents and add any virtual methods that are
        //necessary
        Iterator<Class> parentIterator = GetParentClasses()
        repeat while parentIterator:HasNext()
            Class mom = parentIterator:Next()
            computed:Add(mom:GetStaticKey(), mom)
            Iterator<Action> momActions = mom:GetActions()
            repeat while momActions:HasNext()
                Action act = momActions:Next()
                WeaveActionFromDirectParent(mom, act, errors)                
            end
        end
    end
    
    action WeaveActionFromDirectParent(Class mom, Action act, CompilerErrorManager errors)
        text key = act:GetStaticKey()
        Type returnType = act:GetReturnType()
        text returnKey = returnType:GetStaticKey()

        Action actionCopy = virtualActions:GetValue(key)
        if actionCopy = undefined //it doesn't exist, so add it.
           virtualActions:Add(key, act) 
           parentActions:Add(key, act) 
        else
            //check to see if the action is overriden
            Action baseAction = actions:GetValue(key)

            //if it exists, just make sure it has the same return type
            if baseAction not= undefined
                Class dad = baseAction:GetParentClass()
                Type baseReturnType = baseAction:GetReturnType()
                text baseReturnKey = baseReturnType:GetStaticKey()

                //if the returnType of the parent (returnType) has a generic, map it
                //to the specific isntance located in the class template declaration
                //if it isn't an Object or isn't a generic, don't map generic types
                if returnType:IsMappedToGeneric() and returnType:GetStaticKey() = returnType:OBJECT_KEY
                    text genericName = returnType:GetMappedGeneric()

                    if mom:HasGeneric(genericName)
                        //get the index of the generic from the parent
                        integer index = mom:GetIndexOfGeneric(genericName)

                        //this tells us the index of the template
                        //now grab the nth element from the declared type list
                        //if it exists. If it doesn't, ignore this
                        Array<Type> values = GetParentGenerics(mom:GetStaticKey())
                        if values not= undefined //sizing is already checked
                            Type actualType = values:Get(index)
                            //if it's not a generic, set the return type value
                            //to the declared value and see if it matches
                            if actualType:GetStaticKey() not= actualType:OBJECT_KEY
                                returnType = actualType
                                returnKey = returnType:GetStaticKey()
                            end
                        end
                    end
                end

                if returnKey not= baseReturnKey //this is an error
                    CompilerError error
                    CompilerErrorType t
                    t:SetCurrentType(t:INHERITANCE_MISSMATCHED_RETURN)
                    error:SetCompilerErrorType(t)
                    error:SetErrorMessage("The action " + key + " is defined in the parent "
                        + dad:GetStaticKey() + ", but the return types (" 
                        + baseReturnKey + " and "+ returnKey + ") do not match.")
                    error:SetLocation(mom)
                    errors:Add(error)
                end //otherwise, everything is fine, so ignore it
            else //the base action is undefined, this could be an error
                 //or it could be the case that the method is from a subclass,
                 //and as such, this is just fine. Or, it could be the case
                 //that the method is in a super class, and as such, needs to be
                 //overriden
                 Class dad = actionCopy:GetParentClass()
                 if dad:HasParentClass(mom:GetStaticKey()) //ignore this, everything is fine
                    a = 5
                 elseif mom:HasParentClass(dad:GetStaticKey())
                    virtualActions:Set(key, act) 
                    parentActions:Set(key, act) 
                 else
                    if act:IsBlueprint() or actionCopy:IsBlueprint()
                       //check to see if the one in the v-table is a blueprint
                       //check to make sure both of them aren't blueprints
                       if not (act:IsBlueprint() and actionCopy:IsBlueprint())
                           //at least one is not a blueprint, so make sure
                           //that is the one in the v-table
                           if actionCopy:IsBlueprint()
                               virtualActions:Set(act:GetStaticKey(), act)
                           end
                       end

                    else

                       CompilerError error
                       error:SetErrorMessage("The action " + key + " is defined"
                          +   " in parents " + mom:GetStaticKey() + " and " 
                          + dad:GetStaticKey() + ". Since I cannot determine which action should"
                          + " be called, the action must be overriden in the"
                          + " base class " + me:GetStaticKey() + ".")
                       error:SetLocation(me)
                       errors:Add(error)
                    end
                 end
            end
        end
    end

    action GetVirtualTable returns Iterator<Action>
        return virtualActions:GetValueIterator()
    end

    action GetParentActions returns Iterator<Action> 
        return parentActions:GetValueIterator()
    end

    /*
        This action returns a list of of all generic names. For example, if
        the class is declared as A<Type, Value>, then this action will return
        "Type, Value" without double quotes.
    */ 
    action GetGenericList returns text
        text value = ""
        
        i = 0
        repeat GetNumberGenerics() times
            if i = 0
                value = value + GetGeneric(i)
            else 
                value = value + ", " + GetGeneric(i)
            end
            i = i + 1
        end
        return value
    end

    action Add(Action method) returns CompilerError
        if not IsDefined(method)
            actions:Add(method:GetStaticKey(), method)
            if method:IsMain()
                hasMain = true
            end

            if method:IsSystem()
                hasSystemAction = true
            end
            return undefined
        end

        CompilerError error
        error:SetLineNumber(method:GetLineNumber())
        error:SetFile(method:GetFile())
        error:SetErrorMessage("Action " + method:GetDisplayName() + " has already been defined.")
        return error
    end

    action HasSystemAction returns boolean
        return hasSystemAction
    end

    /*
        This action returns whether or not this particular class
        represents Libraries.Language.Object.
    */
    action IsObject returns boolean
        if GetStaticKey() = LIBRARIES_LANGUAGE_OBJECT
            return true
        else
            return false
        end
    end


    /*
        This action returns true if this class is either Libraries.Language.Errors.Error
        or is a subclass.
    */
    action IsError returns boolean
        if GetStaticKey() = LIBRARIES_LANGUAGE_ERRORS_ERROR
            return true
        elseif HasParentClass(LIBRARIES_LANGUAGE_ERRORS_ERROR)
            return true
        else
            return false
        end
    end

    action GenerateSetterNameFromField(Variable variable) returns text
        text result = "Set$"
        result = result + ConvertStaticKeyToFieldPath() + variable:GetName()
        return result
    end

    action ConvertToActionNameFromField(Variable variable, boolean isGetter) returns text
        text result = ""

        if isGetter
            result = result + "Get$"
        else
            result = result + "Set$"
        end
        
        result = result + ConvertStaticKeyToFieldPath() + "$" + variable:GetName()
        return result
    end

    action AddUnresolvedParent(QualifiedName name)
        unresolvedParents:Add(name)
    end

    action AddParentClass(Class clazz) //check for compiler error or just ignore?
        parents:Add(clazz:GetStaticKey(), clazz)
    end
    
    /*
        This action checks to see if all types have been resolved for this class.
    */
    action IsResolved returns boolean
        return isTypeResolved
    end

    action ResolveUseStatements(SymbolTable table, CompilerErrorManager errors)
        //first resolve all use statements
        Iterator<QualifiedName> unresolvedUse = GetUnresolvedUseStatements()
        repeat while unresolvedUse:HasNext()
            QualifiedName name = unresolvedUse:Next()
            text key = name:GetStaticKey()

            
            //if this is an all statement, then grab anything in the container
            if name:IsAll()
                noAllKey = name:GetStaticKeyNoAll()
                Iterator<Class> classes = table:GetClassesInPackage(noAllKey)
                if classes not= undefined
                    repeat while classes:HasNext()
                        Class clazz = classes:Next()
                        AddValidUse(clazz)
                    end
                else
                    CompilerError error
                    error:SetLocation(name)
                    CompilerErrorType type
                    type:SetCurrentType(type:MISSING_USE)
                    error:SetCompilerErrorType(type)
                    error:SetErrorMessage("I could not locate the package named "
                        +  noAllKey + ". Are you sure you spelled it correct?" )
                    errors:Add(error)
                end
            else 
                Class clazz = GetClass(name:GetStaticKey(), table, errors)
                if clazz not= undefined
                    AddValidUse(clazz)
                else
                    CompilerError error
                    error:SetLocation(name)
                    CompilerErrorType type
                    type:SetCurrentType(type:MISSING_USE)
                    error:SetCompilerErrorType(type)
                    error:SetErrorMessage("I could not locate the use statement named "
                        +   name:GetStaticKey() + ". Are you sure you spelled it correct?" )
                    errors:Add(error)
                end
            end
        end
    end

    action ResolveAllTypes(SymbolTable table, CompilerErrorManager errors)
        //next resolve all parents
        ResolveParents(table, errors)
        ResolveParentLevels(table)

        //now all parents are resolved. Resolve the generics of those parents
        //first rehash all of the parent uses
        ResolveParentGenerics(table, errors)
        
        //now resolve all the fields
        ResolveFields(table, errors)

        //next resolve all actions and their blocks
        ResolveActions(table, errors)

        MapParentGenerics()
        isTypeResolved = true
    end

    action HasGenerics returns boolean
        return GetNumberGenerics() not= 0
    end

    private action MapParentGenerics
        HashTable<text, HashTable<integer, integer>> map
        text key = GetStaticKey()

        Iterator<text> parents = parentGenerics:GetKeyIterator()
        repeat while parents:HasNext()
            text next = parents:Next()
            HashTable<integer, integer> parentMap
            Array<Type> gens = GetParentGenerics(next)
            i = 0
            repeat while i < gens:GetSize()
                Type type = gens:Get(i)
                if type:IsMappedToGeneric()
                    text gen = type:GetMappedGeneric()
                    if HasGeneric(gen)
                        text mappedValue = undefined
                        integer mappedIndex = -1
                        j = 0
                        repeat while j < generics:GetSize()
                            text myGeneric = generics:Get(j)
                            if myGeneric = gen
                                mappedValue = gen
                                mappedIndex = j
                            end
                            j = j + 1
                        end

                        if not (mappedValue = undefined)
                            parentMap:Add(i, mappedIndex)
                        end
                    else

                    end
                    
                end
                if not parentMap:IsEmpty()
                    map:Add(next, parentMap)
                end
                i = i + 1
            end
        end
        parentGenericMap = map
    end

    action HasGenericMapToParent(text key) returns boolean
        if parentGenericMap:HasKey(key)
            return true
        end

        return false
    end

    action ComputeGenericsTables(CompilerErrorManager compilerErrorManager)
        Iterator<text> it = parentGenericMap:GetKeyIterator()
        HashTable<text, HashTable<integer, integer>> tempParentMap
        
        HashTable<text, HashTable<integer, integer>> finalParentMap
        repeat while it:HasNext()
            text next = it:Next()
            tempParentMap:Add(next, parentGenericMap:GetValue(next))
            finalParentMap:Add(next, parentGenericMap:GetValue(next))
        end

        it = tempParentMap:GetKeyIterator()
        text key = GetStaticKey()
        b = 5

        repeat while it:HasNext()
            HashTable<text, HashTable<integer, integer>> newTempParentMap
            repeat while it:HasNext()
                text next = it:Next()
                Class par = GetParentClass(next)
                HashTable<text, HashTable<integer, integer>> parentMap = par:GetParentGenericMap()
                if not parentMap:IsEmpty()
                    Iterator<text> parentIt = parentMap:GetKeyIterator()
                    HashTable<integer, integer> directParentMap = tempParentMap:GetValue(next)

                    repeat while parentIt:HasNext()
                        text nextParent = parentIt:Next()
                        //do we already have a map from this class to this parent?

                        HashTable<integer, integer> values = parentMap:GetValue(nextParent)
                        HashTable<integer, integer> myValues = parentGenericMap:GetValue(nextParent)
                        //if so, check it for consistency
                        if values not= undefined
                            if myValues = undefined //we don't have a map to this parent
                                HashTable<integer, integer> newMap
                                Iterator<integer> myClassValues = directParentMap:GetValueIterator()
                                repeat while myClassValues:HasNext()
                                    integer val = myClassValues:Next()
                                    if values:HasKey(val)
                                        newMap:Add(val, values:GetValue(val))
                                    end
                                end
                                if not newMap:IsEmpty()
                                    if not parentGenericMap:HasKey(nextParent)
                                        newTempParentMap:Add(nextParent, newMap)
                                        parentGenericMap:Add(nextParent, newMap)
                                    end
                                end
                            else
                                boolean test = CheckHashTableConsistency(
                                    compilerErrorManager, values, 
                                    myValues, next, nextParent)
                                
                                //I don't think anything needs to be done with this value
                                //if it fails, as an error will be issued.
                            end
                        end
                    end
                end
            end

            tempParentMap = newTempParentMap
            it = tempParentMap:GetKeyIterator()
        end
    end

    private action GetPositionName(integer pos) returns text
        text message = "the "
        if pos = 0
            return message + "first"
        elseif pos = 1
            return message + "second"
        elseif pos = 2
            return message + "third"
        elseif pos = 3
            return message + "fourth"
        elseif pos = 4
            return message + "fifth"
        elseif pos = 5
            return message + "sixth"
        elseif pos = 6
            return message + "seventh"
        elseif pos = 7
            return message + "eighth"
        elseif pos = 8
            return message + "ninth"
        elseif pos = 9
            return message + "tenth"
        end

        return " position " + (pos + 1) 
    end

    private action CheckHashTableConsistency(CompilerErrorManager compilerErrorManager, 
        HashTable<integer, integer> left, HashTable<integer, integer> right, text next, text nextParent) returns boolean
        lsize = left:GetSize()
        rsize = right:GetSize()

        //if these do not match, it's an error
        if lsize not= rsize
            CompilerError error
            error:SetLocation(me)
            CompilerErrorType t
            t:SetCurrentType(t:MISMATCHED_TEMPLATES)
            error:SetCompilerErrorType(t)
            text message = "The class " + GetStaticKey() + " defines generics "
            message = message + "that lead to its parent class " + nextParent + 
                " having two different definitions."
            error:SetErrorMessage(message)
            compilerErrorManager:Add(error)
            return false
        end

        Iterator<integer> lit = left:GetKeyIterator()
        repeat while lit:HasNext()
            lkey = lit:Next()

            lval = left:GetValue(lkey)

            if right:HasKey(lkey)
                rval = right:GetValue(lkey)
                if lval not= rval
                    CompilerError error
                    error:SetLocation(me)
                    CompilerErrorType t
                    t:SetCurrentType(t:MISMATCHED_TEMPLATES)
                    error:SetCompilerErrorType(t)
                    text message = "The class " + GetStaticKey() + " defines generics "
                    message = message + "that lead to its parent class " + nextParent + 
                        " having two contradictory values, " + GetPositionName(lval) + " (" + GetGeneric(lval) + "), and " + 
                        GetPositionName(rval) + " (" + GetGeneric(rval) + "). In this case, this is caused by "
                        + "the definition of the parent " + next + "."
                    error:SetErrorMessage(message)
                    compilerErrorManager:Add(error)
                    return false
                end
            else
                CompilerError error
                error:SetLocation(me)
                CompilerErrorType t
                t:SetCurrentType(t:MISMATCHED_TEMPLATES)
                error:SetCompilerErrorType(t)
                text message = "The class " + GetStaticKey() + " defines generics "
                message = message + "that lead to its parent class " + nextParent + 
                    " having two contradictory values, position " + lval + " (" + GetGeneric(lval) + "), and an undefined definition."
                error:SetErrorMessage(message)
                compilerErrorManager:Add(error)
                return false
            end
        end

        return true
    end

    private action GetParentGenericMap returns HashTable<text, HashTable<integer, integer>>
        return parentGenericMap
    end

    action MapParentGenericToMe(text parentKey, integer index) returns integer
        if HasParentClass(parentKey)

            //do we have a map for this generic?
            HashTable<integer, integer> map = parentGenericMap:GetValue(parentKey)
            if map not= undefined
                return map:GetValue(index)
            else //we couldn't find the map. Ask the parent, and any of its parents, if it has one
                //check all of the maps to see if any of them lead to the one
                //in question. If this is not unique, is this an issue? Think on this more
                

            end
        end

        return -1
    end

    private action ResolveParentGenerics(SymbolTable table, CompilerErrorManager errors)
        //before we tackle the generics, lets setup all the parents as valid 
        //uses.
        Iterator<Class> myParents = GetParentClasses()
        repeat while myParents:HasNext()
            Class c = myParents:Next()
            AddValidUse(c)
        end

        HashTable<text, Array<Type>> newParentGenerics
        Iterator<text> keys = parentGenerics:GetKeyIterator()
        repeat while keys:HasNext()
            text key = keys:Next()
            Array<Type> theTypes = parentGenerics:GetValue(key)
            Class clazz = me:GetValidUseName(key)
            if clazz = undefined //could be ok if this is a generic
                if HasGeneric(key) //hash it as the type, which will be unique
                    newParentGenerics:Set(key, theTypes)
                else 
                    CompilerError error
                    error:SetLocation(me)
                    error:SetErrorMessage("I could not locate a class named " + key
                        + " from the class " + GetStaticKey() + "."
                    )
                    CompilerErrorType errorType
                    errorType:SetCurrentType(errorType:MISSING_USE)
                    error:SetCompilerErrorType(errorType)
                    errors:Add(error)
                end
            else
                newParentGenerics:Set(clazz:GetStaticKey(), theTypes)
            end
        end
        parentGenerics = newParentGenerics


        Iterator<Class> parentIterator = parents:GetValueIterator()
        repeat while parentIterator:HasNext()
            Class next = parentIterator:Next()
            key = next:GetStaticKey()
            Array<Type> types = GetParentGenerics(key)

            //first check if the class actually has any declared generics
            //if it doesn't, make sure the user didn't specify any
            boolean hasGenerics = next:HasGenerics()
            if hasGenerics = false
                if types not= undefined
                    if not types:IsEmpty() //the class has no generics, but the user tried to specify them
                        CompilerError error
                        error:SetLocation(me)
                        error:SetErrorMessage("I noticed there were generics specified for "
                            + "the parent " + next:GetStaticKey() + ", but this class "
                            + "does not have any generics."
                        )
                        CompilerErrorType errorType
                        errorType:SetCurrentType(errorType:MISMATCHED_TEMPLATES)
                        error:SetCompilerErrorType(errorType)
                        errors:Add(error)
                    end
                end
            else
                //if it does have generics, but the user didn't specify any
                //that's just fine. No need to do anything for this case
                

                //if there are generics, and they are specified, make sure
                //that the number of generics is exactly the same. If it isn't
                //that's an error, as it has to match.
                if types not= undefined
                    //first check that the number of parameters matches
                    baseSize = types:GetSize()
                    parentSize = next:GetNumberGenerics()
                    if baseSize not= parentSize
                        CompilerError error
                        error:SetLocation(me)
                        error:SetErrorMessage("I noticed there were generics specified for "
                            + "the parent " + next:GetStaticKey() + ", but this class "
                            + "has " + parentSize + " generics declared, but you " 
                            + "specified " + baseSize + "."
                        )
                        CompilerErrorType errorType
                        errorType:SetCurrentType(errorType:MISMATCHED_TEMPLATES)
                        error:SetCompilerErrorType(errorType)
                        errors:Add(error)
                    else 
                        //the numbers match, so line them up.
                        i = 0
                        repeat baseSize times
                            Type baseType = types:Get(i)
                            //resolve this type. If there are no errors, we're good.
                            ResolveType(me, baseType, table, errors)
                            i = i + 1
                        end
                    end
                end
            end
        end
    end

    private action ResolveFields(SymbolTable table, CompilerErrorManager errors)
        Iterator<Variable> iterator = GetVariables()    
        repeat while iterator:HasNext()
            Variable var = iterator:Next()
            ResolveVariable(var, table, errors)
        end
    end

    action GetInterfaceName returns text
        text name = GetName()
        return name + "$Interface"
    end

    private action ResolveActions(SymbolTable table, CompilerErrorManager errors)
        Iterator<Action> actionIterator = me:GetActions()
        Array<Action> temp
        repeat while actionIterator:HasNext()
            Action next = actionIterator:Next()
            temp:Add(next)

            //first, we resolve the parameters
            Iterator<Variable> parameters = next:GetParameterIterator()
            repeat while parameters:HasNext()
                Variable param = parameters:Next()
                ResolveParameterType(param, param:GetType(), table, errors)
            end

            Type returnType = next:GetReturnType()
            if not returnType:IsVoid()
                ResolveParameterType(next, returnType, table, errors)
            end

            //next we resolve all of the variables in its blocks
            if next:GetBlock() not= undefined
                ResolveBlock(next:GetBlock(), table, errors)
            end
        end

        //now resolve the constructor, if one exists
        Action constructor = GetConstructor()
        if constructor not= undefined
            ResolveBlock(constructor:GetBlock(), table, errors)
        end

        //now we pull all actions out of the hash and re-hash them,
        //now with resolved type names and keys
        hasMain = false
        actions:Empty()
        actionIterator = temp:GetIterator()
        repeat while actionIterator:HasNext()
            Action next = actionIterator:Next()
            CompilerError error = Add(next)
            if error not= undefined
                errors:Add(error)
            end
        end
    end

    action ResolveFrames
        Iterator<Action> actionIterator = me:GetActions()
        repeat while actionIterator:HasNext()
            Action next = actionIterator:Next()
            if not next:IsSystem() and not next:IsBlueprint()
                Block b = next:GetBlock()
                b:AssignBytecodeLocations()
            end
        end
        if constructor not= undefined
            Block b = constructor:GetBlock()
            b:AssignBytecodeLocations()
        end
    end

    private action ResolveBlock(Block block, SymbolTable table, CompilerErrorManager errors)
        //first resolve all of the variables in this block
        Iterator<Variable> variables = block:GetVariables()
        repeat while variables:HasNext()
            Variable next = variables:Next()
            ResolveVariable(next, table, errors)
        end

        //next resolve any variables in the children
        Iterator<Block> blocks = block:GetBlocks()
        repeat while blocks:HasNext()
            Block next = blocks:Next()
            ResolveBlock(next, table, errors)
        end
    end

    private action ResolveParameterType(Location location, Type type, SymbolTable table, CompilerErrorManager errors)
        if type = undefined //this is an implicit type, which has to be a primitive
                            //therefore, it is safe to ignore this
            return now
        end

        //check if this class has generics. If it does, either map
        //the parameter to a generic or resolve it normally.
        if GetNumberGenerics() > 0
            key = type:GetStaticKey()
            if HasGeneric(key)
                //this is a generic parameter. Set it to object, but map it
                //to this generic name
                type:MapToGeneric(key)
                type:SetToObject(type:OBJECT_KEY)
            else
                ResolveType(location, type, table, errors)
            end

        else
            ResolveType(location, type, table, errors)
        end
    end

    private action ResolveVariable(Variable variable, SymbolTable table, CompilerErrorManager errors)
        Type type = variable:GetType()
        if type = undefined //this is an implicit type, which has to be a primitive
                            //therefore, it is safe to ignore this
            return now
        end
        ResolveType(variable, type, table, errors)
    end

    action ResolveType(Location location, Type type, SymbolTable table, CompilerErrorManager errors)
        if not type:IsPrimitive() //if it's a primitive, do nothing
            text key = type:GetStaticKey()
            Class clazz = GetClass(key, table, errors)
            if clazz not= undefined
                has = HasGeneric(key)
                if has
                    type:MapToGeneric(key)
                end
                type:SetToObject(clazz:GetStaticKey())
                if type:HasGenerics()
                    //check to see if the number of generics matches with the class
                    if clazz:GetNumberGenerics() not= type:GetNumberGenerics() 
                        CompilerError error
                        error:SetLocation(location)
                        CompilerErrorType t
                        t:SetCurrentType(t:MISMATCHED_TEMPLATES)
                        error:SetCompilerErrorType(t)
                        error:SetErrorMessage("I noticed there is a variable of type "
                            +  key + ". This class requires " + clazz:GetNumberGenerics()
                            + " generics, but there are " + type:GetNumberGenerics() + " defined.")
                        errors:Add(error)
                    end


                    Iterator<Type> generics = type:GetGenerics()
                    repeat while generics:HasNext()
                        Type generic = generics:Next()
                        if type:HasGenerics()
                            ResolveType(location, generic, table, errors)
                        end
                    end
                end
            else
                CompilerError error
                error:SetLocation(location)
                CompilerErrorType t
                t:SetCurrentType(t:MISSING_USE)
                error:SetCompilerErrorType(t)
                error:SetErrorMessage("I could not locate a type named "
                    +  key + ". Are you sure you spelled it correctly?" )
                errors:Add(error)
            end
        end
    end

    private action ResolveType(Variable variable, Type type, SymbolTable table, CompilerErrorManager errors)
        if not type:IsPrimitive() //if it's a primitive, do nothing
            text key = type:GetStaticKey()
            Class clazz = GetClass(key, table, errors)
            if clazz not= undefined
                type:SetToObject(clazz:GetStaticKey())
                if type:HasGenerics()
                    //check to see if the number of generics matches with the class
                    if clazz:GetNumberGenerics() not= type:GetNumberGenerics() 
                        CompilerError error
                        error:SetLocation(variable)
                        CompilerErrorType t
                        t:SetCurrentType(t:MISMATCHED_TEMPLATES)
                        error:SetCompilerErrorType(t)
                        error:SetErrorMessage("I noticed there is a variable of type "
                            +  key + ". This class requires " + clazz:GetNumberGenerics()
                            + " generics, but there are " + type:GetNumberGenerics() + " defined.")
                        errors:Add(error)
                    end


                    Iterator<Type> generics = type:GetGenerics()
                    repeat while generics:HasNext()
                        Type generic = generics:Next()
                        if type:HasGenerics()
                            ResolveType(variable, generic, table, errors)
                        end
                    end
                end
            else
                CompilerError error
                error:SetLocation(variable)
                CompilerErrorType t
                t:SetCurrentType(t:MISSING_USE)
                error:SetCompilerErrorType(t)
                error:SetErrorMessage("I could not locate a type named "
                    +  key + ". Are you sure you spelled it correctly?" )
                errors:Add(error)
            end
        end
    end

    /*
        This action resolves a type that lives in an action.
    */
    private action ResolveType(Action act, Type type, SymbolTable table, CompilerErrorManager errors)
        if not type:IsPrimitive() //if it's a primitive, do nothing
            text key = type:GetStaticKey()
            Class parentForAction = act:GetParentClass()
            if parentForAction:HasGeneric(type:GetStaticKey())
                //this is referencing a generic, so there's no need to check
                //the symbol table. Grab Object and tell it its mapped
                //generic name
                type:MapToGeneric(key)
                type:SetToObject(type:OBJECT_KEY)
                return now
            end

            Class clazz = GetClass(key, table, errors)
            if clazz not= undefined
                type:SetToObject(clazz:GetStaticKey())
                if type:HasGenerics()
                    //check to see if the number of generics matches with the class
                    if clazz:GetNumberGenerics() not= type:GetNumberGenerics() 
                        CompilerError error
                        error:SetLocation(act)
                        CompilerErrorType t
                        t:SetCurrentType(t:MISMATCHED_TEMPLATES)
                        error:SetCompilerErrorType(t)
                        error:SetErrorMessage("I noticed there is a variable of type "
                            +  key + ". This class requires " + clazz:GetNumberGenerics()
                            + " generics, but there are " + type:GetNumberGenerics() + " defined.")
                        errors:Add(error)
                    end


                    Iterator<Type> generics = type:GetGenerics()
                    repeat while generics:HasNext()
                        Type generic = generics:Next()
                        if type:HasGenerics()
                            ResolveType(act, generic, table, errors)
                        end
                    end
                end
            else
                CompilerError error
                error:SetLocation(act)
                CompilerErrorType t
                t:SetCurrentType(t:MISSING_USE)
                error:SetCompilerErrorType(t)
                error:SetErrorMessage("I could not locate a type named "
                    +  key + ". Are you sure you spelled it correctly?" )
                errors:Add(error)
            end
        end
    end

    action ResolveActionKey(text name, Iterator<Variable> parameters, 
        SymbolTable table, CompilerErrorManager errors) returns text
        text final = name
        
        repeat while parameters:HasNext()
            Variable param = parameters:Next()
            Type type = param:GetType()
            if type:IsPrimitive()
                final = final + ":" + type:GetStaticKey() 
            else
                Class clazz = GetClass(type:GetStaticKey(), table, errors)
                if clazz not= undefined //if it is, an error has been issued
                    final = final + ":" + clazz:GetStaticKey()
                end

                //does the type have generics
                //if type:HasGenerics()
                //    Iterator<Type> generics = type:GetGenerics()
                //    final = final + GetGenericKey(generics, table, errors)
                //end
            end
        end

        return final
    end

    private action GetGenericKey(Iterator<Type> generics, 
        SymbolTable table, CompilerErrorManager errors) returns text
        text final = "<"
        first = true
        repeat while generics:HasNext()
            Type type = generics:Next()
            
            if type:IsPrimitive()
                if first
                    final = final + type:GetStaticKey() 
                    first = false
                else
                    final = final + ":" + type:GetStaticKey() 
                end
                
            else
                Class clazz = GetClass(type:GetStaticKey(), table, errors)
                if clazz not= undefined //if it is, an error has been issued
                    if first
                        final = final + clazz:GetStaticKey()
                        first = false
                    else
                        final = final + ":" + clazz:GetStaticKey()
                    end
                    
                end

                //does the type have generics
                if type:HasGenerics()
                    Iterator<Type> gen = type:GetGenerics()
                    final = final + GetGenericKey(gen, table, errors)
                end
            end
        end

        return final + ">"
    end

    private action GetClass(text key, SymbolTable table, CompilerErrorManager errors) returns Class
        Class clazz = undefined
        Array<text> split = key:Split("\.")

        //first check if this is a full name in the symbol table. 
        //be careful to check the default package only if this class
        //is in the default package. 
        if split:GetSize() > 1
            clazz = table:GetClass(key)
        end

        if clazz not= undefined
            return clazz
        end
        //next check if this is the name of a generic in this class
        has = HasGeneric(key)
        if has
            Type type
            clazz = table:GetClass(type:OBJECT_KEY)
        end

        if clazz not= undefined
            return clazz
        end

        //if we still haven't found it, then check if there are any classes
        //in the current package of the class by that name. If there are, then
        //use that.
        Class fromPackage = table:GetClassInPackage(me:GetPackageKey(), key)

        //is there a name in the use list?
        Class fromUse = me:GetValidUseName(key)

        //is there a name in both the use list and the package?
        //if so, it's a compiler error if they conflict
        //if no name is found, this is an error
        //if the name is unique, use that one and put it in the class
        if fromPackage not= undefined and fromUse = undefined
            clazz = fromPackage
        elseif fromPackage = undefined and fromUse not= undefined
            clazz = fromUse
        elseif fromPackage not= undefined and fromUse not= undefined
            //if both classes are the same, then return it
            if fromPackage:GetStaticKey() = fromUse:GetStaticKey()
                clazz = fromPackage
            else //this is a conflict and a compiler error
                CompilerError error
                text a = ""
                a = a:GetDoubleQuote()
                error:SetErrorMessage("The name " + a + key + a
                    + " could be either " + a + fromPackage:GetStaticKey() + a 
                    + " or " + a + fromUse:GetStaticKey() + a + ". I cannot tell which one you meant." ) 
                //TODO: Add in compiler error line and location.
                errors:Add(error)
            end
        end

        if clazz not= undefined
            return clazz
        end

        if clazz = undefined
            CompilerError error
            CompilerErrorType t
            t:SetCurrentType(t:MISSING_USE)
            error:SetCompilerErrorType(t)
            text a = ""
            a = a:GetDoubleQuote()
            key  = GetStaticKey()
            error:SetErrorMessage("The class name " + a + key + a + 
                " could not be found. Did you forget a use statement?") 
            error:SetLocation(me)
            errors:Add(error)
        end
        //if we still have not found the class, then it cannot be found, 
        //which is an error
        return undefined
    end

    action ResolveParentLevels(SymbolTable table)
        HashTable<text, Class> tempParents
        Array<Array<Class>> leveledParents
        Array<Class> levelOneParents
        leveledParents:Add(levelOneParents)

        Iterator<QualifiedName> names = GetUnresolvedParents()
        repeat while names:HasNext()
            QualifiedName name = names:Next()
            
            Class myParent = table:GetClass(name:GetStaticKey())

            if myParent not= undefined //if it is defined, add it as a valid parent
                if not tempParents:HasKey(myParent:GetStaticKey())
                    levelOneParents:Add(myParent)
                    tempParents:Add(myParent:GetStaticKey(), myParent)
                end
            end //if it is not, ignore it, as an error has already been issued
        end

        directParents = levelOneParents

        Array<Class> currentLevelParents = levelOneParents
        Array<Class> nextLevelParents
        Iterator<Class> nextLevel = currentLevelParents:GetIterator()
        repeat while nextLevel:HasNext()
            Class next = nextLevel:Next()

            Iterator<QualifiedName> nextNames = next:GetUnresolvedParents()
            repeat while nextNames:HasNext()
                QualifiedName name = nextNames:Next()

                Class myParent = table:GetClass(name:GetStaticKey())

                if myParent not= undefined
                    if not tempParents:HasKey(myParent:GetStaticKey())
                        nextLevelParents:Add(myParent)
                        tempParents:Add(myParent:GetStaticKey(), myParent)
                    end
                end //if it is not, ignore it, as an error has already been issued
            end

            //check if this is the last parent in this level.
            //if it is start going over the next level, which might be empty.
            if not nextLevel:HasNext()
                if not nextLevelParents:IsEmpty()
                    leveledParents:Add(nextLevelParents)
                end
                currentLevelParents = nextLevelParents
                Array<Class> classes
                nextLevelParents = classes
                nextLevel = currentLevelParents:GetIterator()
            end
        end

        resolvedParentLevels = leveledParents
    end

    action ResolveParents(SymbolTable table, CompilerErrorManager errors)
        isResolvingParents = true
        Iterator<QualifiedName> names = GetUnresolvedParents()
        repeat while names:HasNext()
            QualifiedName name = names:Next()
            Class myParent = GetClass(name:GetStaticKey(), table, errors)

            if myParent not= undefined //if it is defined, add it as a valid parent
                parents:Add(myParent:GetStaticKey(), myParent)
            end //if it is not, ignore it, as an error has already been issued
        end

        //ok, we now have all first level parents, so check them all
        //if they are already resolved, then flatten their lists and check
        //for circular dependencies
        //if the parents are not resolved, then resolve them before doing this.
        //since each parent's list is flattened after solution,
        //this does not need to go another level deeper.
        Iterator<Class> parentIterator = parents:GetValueIterator()
        repeat while parentIterator:HasNext()
            Class next = parentIterator:Next()
            
            //if this parent is in the middle of a ResolveParents call
            //we have a circular dependency and should throw a compiler error
            //we should also bail out at this point, because the behavior
            //would make no sense
            if next:IsResolvingParents()
                CompilerError error
                text a = ""
                a = a:GetDoubleQuote()
                error:SetErrorMessage("The parent name " + a + next:GetStaticKey() + a + 
                    " has the current class as a parent, but I do not understand what this would mean.") 
                //TODO: Add in compiler error line and location.
                errors:Add(error)

                isResolvingParents = false
                areParentsResolved = true
            end


            //otherwise check if the parent is resolved
            if not next:AreParentsResolved()
                next:ResolveParents(table, errors)
            end
            //the parent is now resolved. 
            Iterator<Class> list = next:GetParentClasses()
            repeat while list:HasNext()
                Class possibleParent = list:Next()
                //if this parent is not in our list, add it
                if not parents:HasKey(possibleParent:GetStaticKey())
                    parents:Add(possibleParent:GetStaticKey(), possibleParent)
                end
            end
        end

        //regardless of whether the user has errors in their code,
        //the parents have been resolved.
        isResolvingParents = false
        areParentsResolved = true
    end

    /*
        This action returns true only if the action ResolveParents is currently
        executing for this class. It is useful in detecting circular inheritance,
        which is not allowed in Quorum.
    */
    action IsResolvingParents returns boolean
        return isResolvingParents
    end

    /*
        This action determines whether this class has a complete
        flattened list of parents from all possible super-classes.
        For example, if we have a class A is B, class B is C, and class C is D,
        then the flattened list of A is B, C, D, and Libraries.Language.Object.
    */
    private action AreParentsResolved returns boolean
        return me:areParentsResolved
    end

    action HasParentClass(text key) returns boolean
        return parents:GetValue(key) not= undefined
    end

    action GetParentClass(text key) returns Class
        return parents:GetValue(key)
    end

    /*
        Obtains a list of all parents reachable from this class. This includes
        parents and the parents of parents as a flattened list.
    */
    action GetParentClasses returns Iterator<Class>
        return parents:GetValueIterator()
    end

    /*
        This action returns those parents that are directly specified 
        in the class. Object is also always included in this list.
    */
    action GetDirectParentClasses returns Iterator<Class>
        return directParents:GetIterator()
    end

    action AddValidUse(Class clazz) returns CompilerError
        name = clazz:GetName()
        if validUses:HasKey(name)
            //see if we're trying to add the same class. If so, it's just fine
            //if it's the same name, but a different class, then throw an error
            Class other = validUses:GetValue(name)
            if other:GetStaticKey() not= clazz:GetStaticKey()
                Class defined = validUses:GetValue(name)
                CompilerError error
                CompilerErrorType type
                type:SetCurrentType(type:USE_AMBIGUOUS)
                error:SetCompilerErrorType(type)
                error:SetErrorMessage("I do not understand what is meant by defining " + name + " as type " + clazz:GetStaticKey() + "." + 
                    " I already defined it as type " + defined:GetStaticKey() + ".")
                return error
            else //it's fine to return undefined, because we just ignored the request
                return undefined
            end
        else
            validUses:Add(name, clazz)
            validUsesFullyQualified:Add(clazz:GetStaticKey(), clazz)
        end
        return undefined
    end

    /*
        Returns the file on disk that contains the implementation of this class.
    */
    action GetFile returns File
        return file
    end

    /*
        Sets a pointer to the file on disk that contains this class.
    */
    action SetFile(File container)
        file = container
    end

    action HasMainAction returns boolean
        if actions:GetValue("Main") not= undefined
            return true
        end
        return false
    end

    action AddUnresolvedUseStatement(QualifiedName name)
        unresolvedUseStatements:Add(name:GetStaticKey(), name)
    end

    action GetUnresolvedUseStatement(text key) returns QualifiedName
        return unresolvedUseStatements:GetValue(key)
    end

    action GetUnresolvedUseStatements returns Iterator<QualifiedName>
        return unresolvedUseStatements:GetValueIterator()
    end

    action GetUnresolvedParents returns Iterator<QualifiedName>
        return unresolvedParents:GetIterator()
    end

    /*
        This action returns a class from a name, like Object, for
        Libraries.Language.Object. It assumes that the name passed in is
        not resolved. Fully resolvable names (Libraries.Language.Object) will
        not be resolved by this action, and as such, need to be resolved
        from the symbol table.
    */
    action GetValidUseName(text name) returns Class
        if validUses:HasKey(name)
            return validUses:GetValue(name)
        end

        return undefined
    end

    action Add(Variable variable) returns CompilerError
        if fields:HasKey(variable:GetStaticKey())
            CompilerError error
            error:SetLineNumber(variable:GetLineNumber())
            error:SetFile(variable:GetFile())
            error:SetErrorMessage("Variable " + variable:GetDisplayName() + " has already been defined in class " + me:GetDisplayName())
            return error
        end
        variable:SetIsField(true)
        fields:Add(variable:GetStaticKey(), variable)
        return undefined
    end

    action GetVariable(text key) returns Variable
        return fields:GetValue(key)
    end

    action GetVariables returns Iterator<Variable> 
        return fields:GetValueIterator()
    end

    action GetAction(text key) returns Action
        return actions:GetValue(key)
    end

    action GetVirtualAction(text key) returns Action
        return virtualActions:GetValue(key)
    end

    action GetActions returns Iterator<Action>
        return actions:GetValueIterator()
    end

    action HasAction(text key) returns boolean
        return actions:HasKey(key)
    end

    private action IsDefined(Action method) returns boolean
        return actions:HasKey(method:GetStaticKey())
    end

    /*
        This action returns whether or not the class has an explicity constructor
        defined. If it returns true, the user has defined a constructor. If
        it returns false, they have not.
    */
    action HasConstructor returns boolean
        return constructor not= undefined
    end

    action GetConstructor returns Action
        return constructor
    end

    action SetConstructor(Action method) 
        constructor = method
    end

    action GetStaticKey returns text
        text pack = packageName:GetStaticKey()
        if pack:IsEmpty()
            return me:GetName()
        end
        return pack + "." + me:GetName()
    end

    /*
        This action returns the static key formatted as a class name in 
        Java bytecode.
    */
    action ConvertStaticKeyToBytecodePath returns text
        text key = GetStaticKey()
        text result = "quorum/" + key:Replace(".", "/")
        return result
    end

    action ConvertStaticKeyToUnderScore returns text
        text key = GetStaticKey()
        text result = "$quorum_" + key:Replace(".", "_")
        return result
    end
    
    /*
        This action returns the static key formatted as a class name in 
        the style of a field.
    */
    action ConvertStaticKeyToFieldPath returns text
        text key = GetStaticKey()
        text result = key:Replace(".", "$")
        return result
    end

    /*
        This action returns the static key formatted as a class name in 
        Java bytecode.
    */
    action ConvertStaticKeyToBytecodeInterfacePath returns text
        text key = GetStaticKey()
        text result = "quorum/" + key:Replace(".", "/") + "$Interface"
        return result
    end

    /*
        This action returns the static key formatted as a plugin class name in 
        Java bytecode.
    */
    action ConvertStaticKeyToPluginPath returns text
        text key = GetStaticKey()
        text result = "plugins/quorum/" + key:Replace(".", "/")
        return result
    end

    /*
        This action returns the static key formatted as a plugin class type name in 
        Java bytecode.
    */
    action ConvertStaticKeyToPluginPathTypeName returns text
        text key = GetStaticKey()
        text result = "Lplugins/quorum/" + key:Replace(".", "/") + ";"
        return result
    end

    /*
        Returns the name of the plugin for this class.
    */
    action GetPluginName returns text
        return "<plugin>"
    end

    /*
        This action returns the static key formatted as a type name in
        Java bytecode.
    */
    action ConvertStaticKeyToBytecodePathTypeName returns text
        text key = GetStaticKey()
        text result = "Lquorum/" + key:Replace(".", "/") + ";"
        return result
    end

    /*
        This action returns the static key formatted as a type name in
        Java bytecode. This version acts as an interface type.
    */
    action ConvertStaticKeyToBytecodePathTypeNameInterface returns text
        text key = GetStaticKey()
        text result = "Lquorum/" + key:Replace(".", "/") + "$Interface;"
        return result
    end

    action GetHiddenVariableName() returns text
        return "$hidden$"
    end

    /*
        This action converts the static key of this class to a 
        name that can be used by the compiler as a class field name.
        An example would be that Libraries.Language.Object becomes
        $Libraries/Language/Object.
    */
    action ConvertStaticKeyToParentFieldName returns text
        text key = GetStaticKey()
        text result = "$" + key:Replace(".", "$")
        return result
    end

    /*
        This action converts the static key of this class to a 
        name that can be used by the compiler as a class field name.
        An example would be that Libraries.Language.Object becomes
        $Libraries/Language/Object.
    */
    action ConvertStaticKeyToParentFieldInterfaceName returns text
        text key = GetStaticKey()
        text result = "$" + key:Replace(".", "$") + "$Interface"
        return result
    end

    /*
        This returns a key related to the package a class is contained in. For
        example, if a class's fully qualified name is Libraries.Language.Object,
        then this would return Libraries.Langauge. If the class's fully qualified
        name is Bob, then this would return the empty string, which indicates
        the default package.
    */
    action GetPackageKey returns text
        text pack = packageName:GetStaticKey()
        return pack
    end

    action GetDisplayName returns text
        return GetStaticKey()
    end

    action GetPackage returns QualifiedName
        return packageName:Copy()
    end

    action ResolveAction(ActionCall call) returns ActionCallResolution
        ActionCallResolution resolution
        Array<Type> parameters = call:actualParameters
        TypeChecker checker = call:checker

        Array<Action> named //actions with the right name
        Array<integer> scores
        Array<Action> matches
        Iterator<Action> all = virtualActions:GetValueIterator()
        repeat while all:HasNext()
            Action act = all:Next()
            if act:GetName() = call:name //the name is right
                calledParameterSize = parameters:GetSize()
                actualParameterSize = act:GetParametersSize()

                if calledParameterSize = actualParameterSize //the number of parameters match
                    named:Add(act)
                end
            end
        end

        if named:IsEmpty()
            resolution:isResolved = false
            CompilerError error
            error:SetLocation(call)
            CompilerErrorType errorType
            errorType:SetCurrentType(errorType:MISSING_METHOD)
            error:SetCompilerErrorType(errorType)
            error:SetErrorMessage("I could not find an action named '" + 
                call:name + "' in the class '" + me:GetStaticKey() + "'")
            error:SetLocation(call)
            resolution:error = error
            return resolution
        end
        Operation implicit
        implicit:SetOperation(implicit:IMPLICIT_CAST)

        Iterator<Action> it = named:GetIterator()
        //assume they have an equal number of parameters
        repeat while it:HasNext() 
            Action act = it:Next()
            i = 0
            integer actionPoints = 0
            Iterator<Variable> variables = act:GetParameterIterator()
            boolean isMatch = true
            repeat while variables:HasNext() and isMatch
                Variable formalParameter = variables:Next()
                Type formalParameterType = formalParameter:GetType()
                Type actualParameterType = parameters:Get(i)
                
                //Check the types to make sure that they are compatible
                TypeCheckResult result = checker:Check(formalParameterType, actualParameterType, implicit, false)
                CompilerError error = result:GetCompilerError(call)
                if error not= undefined //this action is not a match. We can break out
                    isMatch = false
                else 
                    TypeConversionPoints points = result:points
                    actionPoints = actionPoints + points:GetPoints()
                end
                i = i + 1
            end

            if isMatch
                matches:Add(act)
                scores:Add(actionPoints)
            end
        end
        
        Array<Action> finalMatches
        integer minPoints = 0
        minPoints = minPoints:GetMaximumValue()
        i = 0
        repeat matches:GetSize() times
            Action act = matches:Get(i)
            integer points = scores:Get(i)
            
            if points < minPoints
                minPoints = points
                finalMatches:Empty()
                finalMatches:Add(act)
            elseif points = minPoints
                finalMatches:Add(act)
            end

            i = i + 1
        end

        if finalMatches:GetSize() = 1
            resolution:resolvedAction = finalMatches:Get(0)
            Action final = finalMatches:Get(0)
            //now compute any implicit casts, if there are any
            Array<QuorumOpcode> casts
            Iterator<Variable> variables = final:GetParameterIterator()
            i = 0
            repeat while variables:HasNext()
                Type actual = parameters:Get(i)
                text actualText = actual:GetStaticKey()
                Variable var = variables:Next()
                Type formal = var:GetType()
                text formalText = formal:GetStaticKey()

                //if the formal parameter is a generic, check its declared type
                //then check if there is a conversion from the actual parameter
                //to that type
                if formal:IsMappedToGeneric()
                    Type mappedType
                    Action act = resolution:resolvedAction
                    Variable classInstance = call:variable

                    

                    //if this is null, it's a compiler bug, or a compiler error?
                    if classInstance = undefined
                        //alert("When resolving a generic, we must have a specific variable with a tangible type")
                    else
                        Type declaredGenericFormal = classInstance:GetType()
                        text mappedName = formal:GetMappedGeneric()

                        if HasGeneric(mappedName)
                            integer index = GetIndexOfGeneric(mappedName)
                            integer numGenerics = declaredGenericFormal:GetNumberGenerics()
                            if index not= -1

                                if index >= numGenerics //the user created an object with the wrong generics and it wasn't caught somewhere else
                                    resolution:isResolved = false
                                    CompilerError error
                                    error:SetLocation(call)
                                    CompilerErrorType errorType
                                    errorType:SetCurrentType(errorType:MISMATCHED_TEMPLATES)
                                    error:SetCompilerErrorType(errorType)
                                    error:SetErrorMessage("I found an action with a declared generic of " +
                                        mappedName + ", which is at position " + index + 
                                        " in the class " + declaredGenericFormal:GetStaticKey() + "." +
                                        " However, no generic was declared in the variable " + 
                                        classInstance:GetName() + ".")
                                    error:SetLocation(call)
                                    resolution:error = error
                                    return resolution
                                else
                                    Type gen = declaredGenericFormal:GetGeneric(index)
                                    if gen:IsPrimitive()
                                        Type boxed = gen:Copy()
                                        boxed:SetToObject(boxed:ConvertToNonPrimitiveStaticKey())
                                        gen = boxed
                                        formal = boxed
                                    else //in the case where the generic is an object, do more searching 

                                    end
                                end
                            end
                        end
                    end
                end


                TypeCheckResult result = checker:Check(formal, actual, implicit, false)
                //If this throws an error, it means that there was a generic
                //type that was mismatched.

                if result:errorType not= undefined
                    resolution:isResolved = false
                    CompilerError error = result:GetCompilerError(call)
                    resolution:error = error
                    return resolution
                end

                TypeConversionConstants constants = result:conversion
                if constants:GetConversion() = constants:NONE
                    casts:Add(undefined)
                else
                    QuorumOpcode op = result:GetQuorumOpcode()
                    casts:Add(op)
                end
                resolution:converter = casts

                i = i + 1
            end


            resolution:isResolved = true
        elseif finalMatches:GetSize() > 1 //check all of the scores
            resolution:resolvedAction = undefined
            resolution:isResolved = false
            CompilerError error

            text value = "I could not find an action that uniquely matches with the name '" + 
                call:name + "' in the class '" + me:GetStaticKey() + "' The reason is because the actions "

             Iterator<Action> m = finalMatches:GetIterator()
             repeat while m:HasNext()
                Action a = m:Next()
                value = value + a:GetStaticKey()

                if m:HasNext()
                    value = value + ", and "
                end
             end
             value = value + " all match the parameters."
             
            CompilerErrorType errorType
            errorType:SetCurrentType(errorType:METHOD_CALL_AMBIGUOUS)
            error:SetCompilerErrorType(errorType)
            error:SetErrorMessage(value)
            error:SetLocation(call)
            resolution:error = error
        else //There are no matches
            resolution:resolvedAction = undefined
            resolution:isResolved = false
            CompilerError error
            error:SetLocation(call)
            CompilerErrorType errorType
            errorType:SetCurrentType(errorType:MISSING_METHOD)
            error:SetCompilerErrorType(errorType)
            error:SetErrorMessage("I could not find an action named '" + 
                call:name + "' in the class '" + me:GetStaticKey() + "'")
            resolution:error = error
        end

        return resolution
    end

    action SetPackage(QualifiedName pack)
        packageName = pack:Copy()
    end
end