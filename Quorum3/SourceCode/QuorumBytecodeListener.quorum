package Libraries.Language.Compile

use Libraries.Language.Compile.Context.all
use Libraries.Language.Compile.Translate.JavaBytecodeClassWriter
use Libraries.Language.Compile.Translate.JavaBytecodeMethodWriter
use Libraries.Language.Compile.Translate.QuorumBytecodeConverter
use Libraries.Language.Compile.Translate.JavaBytecodeOpcodes
use Libraries.Language.Compile.Symbol.all
use Libraries.Language.Compile.Translate.all

use Libraries.Containers.Array
use Libraries.Containers.List
use Libraries.Containers.Blueprints.Iterator
use Libraries.System.File
use Libraries.Containers.Stack

class QuorumBytecodeListener is QuorumSourceListener 
    QualifiedName packageValue = undefined
    JavaBytecodeClassWriter classWriter = undefined
    JavaBytecodeClassWriter interfaceWriter = undefined
    JavaBytecodeMethodWriter methodWriter = undefined
    JavaBytecodeMethodWriter interfaceMethodWriter = undefined

    QuorumBytecodeConverter converter
    JavaBytecodeOpcodes opcodes
    Action currentAction = undefined
    ActionOpcode currentActionOpcode = undefined
    ClassOpcode currentClassOpcode = undefined
    boolean isInAction = false

    Class currentClass = undefined
    Block currentBlock = undefined
    constant integer ME = 0
    text build = "TestBuild"
    text run = "TestRun"
    constant text QUORUM = "quorum"

    constant text JAVA_THROWABLE = "java/lang/Throwable"
    constant text JAVA_OBJECT = "java/lang/Object"
    constant text QUORUM_ERROR = "quorum/Libraries/Language/Errors/Error"
    boolean isNormalAction = false
    boolean isSystemAction = false
    boolean isBluePrintAction = false
    boolean isNextVariableReferenceMe = false
    Stack<QuorumOpcode> opcodeStack
    Stack<ConditionalOpcode> ifStack
    Stack<LoopOpcode> loopStack
    File buildFile = undefined
    File buildInterfaceFile = undefined
    BlockOpcode currentBlockOpcode = undefined
    Stack<BlockOpcode> poppedBlockOpcodes
    Stack<BlockOpcode> currentBlocks
    Stack<integer> blockPositionStack
    Stack<ActionExpressionListContext> actionCallParameterStack
    integer loopCounter = 0
    integer ifCount = 0

    action GetBuildFile returns File
        return buildFile
    end

    action GetBuildInterfaceFile returns File
        return buildInterfaceFile
    end
    
    private action SetNormalAction 
        isNormalAction = true
        isSystemAction = false
        isBluePrintAction = false
    end

    private action SetSystemAction 
        isNormalAction = false
        isSystemAction = true
        isBluePrintAction = false
    end

    private action SetBlueprintAction 
        isNormalAction = false
        isSystemAction = false
        isBluePrintAction = true
    end

    private action ClearActionState
        isNormalAction = false
        isSystemAction = false
        isBluePrintAction = false
    end

    action ExitPackageRule(PackageContext context) 
        packageValue = context:name
    end

    action EnterFullClassDeclaration(FullClassDeclarationContext context) 
        JavaBytecodeClassWriter newClassWriter
        JavaBytecodeClassWriter newIinterfaceWriter

        classWriter = newClassWriter
        interfaceWriter = newIinterfaceWriter
        ClassOpcode classOp
        currentClassOpcode = classOp

        text name = context:className
        SymbolTable table = me:GetSymbolTable()
        
        text staticKey = ""
        if packageValue = undefined
            QualifiedName default
            packageValue = default
        end
        staticKey = packageValue:GetClassStaticKey(name)
        currentClass = table:GetClass(staticKey)
        currentClassOpcode:SetClass(currentClass)
        currentClassOpcode:SetName(name)
        currentClassOpcode:SetStaticKey(staticKey)
        currentClassOpcode:SetBuildPath(build)
        currentClassOpcode:SetRunPath(run)
        currentClassOpcode:SetPackage(packageValue)
        currentClassOpcode:SetClassWriter(classWriter)
        currentClassOpcode:SetInterfaceWriter(interfaceWriter)
    end


    action ExitFullClassDeclaration(FullClassDeclarationContext context) 
        if currentClass not= undefined
            currentClassOpcode:Write()
            buildFile = currentClassOpcode:GetBuildFile()
            buildInterfaceFile = currentClassOpcode:GetBuildInterfaceFile()
        end
    end

    action ExitActionHeader(ActionContext context)
        if currentClass not= undefined
            //get the method name
            List<Variable> list = context:parameters
            Iterator<Variable> paramIt = list:GetIterator()
            text key = currentClass:ResolveActionKey(context:actionName, paramIt,
                GetSymbolTable(), GetCompilerErrorManager())

            Action method = currentClass:GetAction(key)
            currentAction = method
            ActionOpcode actionOpcode
            currentActionOpcode = actionOpcode
            currentActionOpcode:SetAction(method)

            boolean isMain = method:IsMain()
            text null = undefined
            text name = method:GetName()
            text params = method:ConvertActionToBytecodeParameterInterfaceSignature()
            methodWriter = 
                classWriter:VisitMethod(opcodes:GetPublic(), 
                name, params, null, undefined)
            currentActionOpcode:SetMethodWriter(methodWriter)
            currentClassOpcode:Add(currentActionOpcode)
        end
    end

    action EnterConstructor(ConstructorContext context) 
        currentAction = currentClass:GetConstructor()
    end

    action ExitConstructor(ConstructorContext context) 
        currentAction = undefined
    end

    action EnterAction(ActionContext context) 
        SetNormalAction()
        isInAction = true
    end

    action ExitAction(ActionContext context) 
        ClearActionState()
        
        if currentActionOpcode not= undefined
            if not poppedBlockOpcodes:IsEmpty()
                currentActionOpcode:Add(poppedBlockOpcodes:Pop())
            end

            //if there are opcodes on the opcode stack for a return, pop them
            //there should never be more than 1, so throw an error if there is
            remaining = opcodeStack:GetSize()
            if remaining not= 0
                if remaining not= 1
                    //alert("Compiler Bug: Cannot have more than 1 remaining opcode on the opcode stack at the end of an action.")
                else 
                    QuorumOpcode op = opcodeStack:Pop()
                    currentActionOpcode:Add(op)
                end
            end
        end
        isInAction = false
    end

    action ExitOutputStatement(OutputContext context)
        QuorumOpcode op = opcodeStack:Pop()
        OutputOpcode out
        out:SetOpcode(op)
        out:SetMethodWriter(methodWriter)
        currentBlockOpcode:Add(out)
    end

    action EnterBlock(BlockContext context)
        if currentBlock = undefined
            currentBlock = currentAction:GetBlock()
            blockPositionStack:Push(0)
        else 
            integer value = blockPositionStack:Pop()
            if value < currentBlock:GetSubBlockSize()
                currentBlock = currentBlock:GetBlock(value)
                blockPositionStack:Push(value + 1)
                //now push on a 0 for the new block
                blockPositionStack:Push(0)
            else 
                alert("Compiler Bug in EnterBlock of the Type Check Listener.")
            end
        end

        if currentBlockOpcode = undefined
            BlockOpcode block
            currentBlockOpcode = block
            currentBlocks:Push(block)
        else
            BlockOpcode block
            block:SetParentBlock(currentBlockOpcode)
            currentBlockOpcode = block
            currentBlocks:Push(block)
        end
    end
    
    action ExitBlock(BlockContext context)
        if currentBlock not= undefined
            currentBlock = currentBlock:GetParentBlock() //may be undefined
            blockPositionStack:Pop()
        end

        if currentBlockOpcode not= undefined
            BlockOpcode op = currentBlocks:Pop()
            poppedBlockOpcodes:Push(op)
            if currentBlocks:IsEmpty()
                currentBlockOpcode = undefined
            else
                currentBlockOpcode = currentBlocks:Peek()
            end
        end
    end

    action EnterLoopStatement(LoopContext context) 
        LoopOpcode loop
        loop:SetMethodWriter(methodWriter)
        if context:isUntil
            loop:SetUntil()
        elseif context:isTimes
            loop:SetTimes()
        else
            loop:SetWhile()
        end

        if context:isTimes
            constant text LOOP_NAME = "Loopy"
            Variable variable = undefined
            variable = currentBlock:GetVariable(loopCounter + LOOP_NAME)
            loop:SetBytecodeLocation(variable:GetBytecodeLocation())
        end

        loopStack:Push(loop)
        loopCounter = loopCounter + 1
    end

    action ExitLoopStatement(LoopContext context) 
        LoopOpcode loop = loopStack:Pop()
        QuorumOpcode qop = opcodeStack:Pop()
        qop:SetIsIfExpression(true)
        

        loop:SetExpression(qop)
        BlockOpcode recentlyPopped = poppedBlockOpcodes:Pop()
        loop:SetBlock(recentlyPopped)
        
        currentBlockOpcode:Add(loop)
    end

    action EnterIfStatement(IfContext context) 
        ConditionalOpcode conditional
        conditional:SetIfLabelInteger(ifCount)
        conditional:SetMethodWriter(methodWriter)

        ifCount = ifCount + 1
        ifStack:Push(conditional)
    end
    

    action ExitIfStatement(IfContext context) 
        ConditionalOpcode conditional = ifStack:Pop()
        QuorumOpcode qop = opcodeStack:Pop()
        qop:SetIsIfExpression(true)
        conditional:SetExpression(qop)
        BlockOpcode recentlyPopped = poppedBlockOpcodes:Pop()
        conditional:SetBlock(recentlyPopped)
        
        currentBlockOpcode:Add(conditional)
    end

    action EnterElseIfStatement(IfContext context) end
    action ExitElseIfStatement(IfContext context) 
        ConditionalOpcode conditional = ifStack:Peek()
        QuorumOpcode qop = opcodeStack:Pop()
        qop:SetIsIfExpression(true)
        BlockOpcode recentlyPopped = poppedBlockOpcodes:Pop()
        conditional:AddElseIf(qop, recentlyPopped)
    end

    action EnterElseStatement(IfContext context) end
    action ExitElseStatement(IfContext context) 
        ConditionalOpcode conditional = ifStack:Peek()
        BlockOpcode recentlyPopped = poppedBlockOpcodes:Pop()
        conditional:SetElseBlock(recentlyPopped)
    end

    action ExitNormalAssignment(NormalAssignmentContext context) 
        text name = context:name
        Variable variable = undefined
        if not isInAction
            variable = currentClass:GetVariable(name)
        else 
            variable = currentBlock:GetVariable(name)
        end

        Type left = variable:GetType()
        QuorumOpcode right = undefined
        if context:hasRightHandSide = false
            Type typeOriginal = context:leftHandSide
            if typeOriginal:IsPrimitive()
                Type type = typeOriginal:Copy()
                type:SetIsConstant(true)
                QuorumConstant const
                const:SetMethodWriter(methodWriter)
                const:SetType(type)
                if type:IsInteger()
                    type:SetIntegerConstant(0)
                    const:integerValue = 0
                elseif type:IsBoolean()
                    type:SetBooleanConstant(false)
                    const:booleanValue = false
                elseif type:IsNumber()
                    type:SetNumberConstant(0.0)
                    const:numberValue = 0.0
                elseif type:IsText()
                    type:SetTextConstant("")
                    const:textValue = ""
                end
                opcodeStack:Push(const)
            else 
                SymbolTable table = me:GetSymbolTable()
                Class clazz = table:GetClass(left:GetStaticKey())
                CreateObjectOpcode opcode
                opcode:SetMethodWriter(methodWriter)
                opcode:SetClass(clazz)
                opcode:SetBytecodeLocation(variable:GetBytecodeLocation())

                if isInAction
                    currentBlockOpcode:Add(opcode)
                    return now
                else //add the opcode to the field calculator
                    currentClassOpcode:AddField(opcode)
                    return now
                end
                
            end
        end

        right = opcodeStack:Pop()


        Operation assign
        assign:SetOperation(assign:EQUALS)

        TypeChecker checker = GetTypeChecker()
        TypeCheckResult result = checker:Check(left, right:GetType(), undefined, true) 

        integer location = variable:GetBytecodeLocation()
        Type value = result:result
        QuorumOpcode qop = result:GetQuorumOpcode()
        AssignmentOpcode assignment = cast(AssignmentOpcode, result:GetQuorumOpcode())
        assignment:SetClass(currentClass)
        assignment:SetRightHandSide(right)
        assignment:SetType(value)
        assignment:SetMethodWriter(methodWriter)
        assignment:SetBytecodeLocation(location)
        assignment:SetVariable(variable)

        if isInAction
            currentBlockOpcode:Add(assignment)
        else //add the opcode to the field calculator
            currentClassOpcode:AddField(assignment)
        end
    end

    action ExitNoTypeAssignment(NoTypeAssignmentContext context) 
        text name = context:name
        Variable variable = undefined

        if context:hasMe or context:isField
            variable = currentClass:GetVariable(name)
            //write the field
        else 
            variable = currentBlock:GetVariable(name)
            Type left = variable:GetType()
            QuorumOpcode right = opcodeStack:Pop()

            Operation assign
            assign:SetOperation(assign:EQUALS)

            TypeChecker checker = GetTypeChecker()
            TypeCheckResult result = checker:Check(left, right:GetType(), undefined, true) 

            integer location = variable:GetBytecodeLocation()
            Type value = result:result
            AssignmentOpcode assignment = cast(AssignmentOpcode, result:GetQuorumOpcode())
            assignment:SetClass(currentClass)
            assignment:SetRightHandSide(right)
            assignment:SetType(value)
            assignment:SetMethodWriter(methodWriter)
            assignment:SetBytecodeLocation(location)
            currentBlockOpcode:Add(assignment)
        end
    end
    
    action EnterVariableFunctionCall(VariableFunctionCallContext context) 
        isNextVariableReferenceMe = context:hasMe
    end
    action ExitVariableFunctionCall(VariableFunctionCallContext context) 
        isNextVariableReferenceMe = false
    end

    action EnterParentVariableFunctionCall(ParentVariableFunctionCallContext context)
        a =5
    end
    action ExitParentVariableFunctionCall(ParentVariableFunctionCallContext context)
        a =5
    end

    action ExitActionExpressionList(ActionExpressionListContext context) 
        actionCallParameterStack:Push(context)
    end

    action ExitActionCall(ActionCallContext context)
        ActionCallOpcode actionCall
        actionCall:SetMethodWriter(methodWriter)

        if context:isActionCall //push the "this" pointer
            actionCall:SetIsActionCall(true)
            ActionExpressionListContext params =  actionCallParameterStack:Pop()
            size = params:size
            

            Array<QuorumOpcode> parametersBackward
            repeat size times
                QuorumOpcode param = opcodeStack:Pop()
                parametersBackward:Add(param)
            end

            Array<Type> parameters
            i = size - 1
            repeat size times
                QuorumOpcode op = parametersBackward:Get(i)
                parameters:Add(op:GetType())
                i = i - 1
            end

            ActionCall call
            call:actualParameters = parameters
            call:name = context:name
            call:checker = GetTypeChecker()
            call:table = GetSymbolTable()
            ActionCallResolution resolved = currentClass:ResolveAction(call)

            if resolved not= undefined and resolved:isResolved//throw a compiler error, if in the type checker, but not in bytecode generator
                actionCall:SetActionCallResolution(resolved)
                actionCall:SetIsActionCall(true)

                actionCall:SetActionCallResolution(resolved)
            end

            i = i
        else //push the variable
            actionCall:SetIsActionCall(false)
            name = context:name
            Variable variable = undefined
            
            if isNextVariableReferenceMe
                variable = currentClass:GetVariable(name)
            else 
                variable = currentBlock:GetVariable(name)
                isNextVariableReferenceMe = false
            end

            if variable not= undefined
                Type type = variable:GetType()
                actionCall:SetType(type)
                actionCall:SetBytecodeLocation(variable:GetBytecodeLocation())
                if variable:IsField()
                else
                end
            end
        end
        opcodeStack:Push(actionCall)
    end

    action ExitReturnStatement(ReturnContext context) 
        Type type = currentAction:GetReturnType()
        if not type:IsVoid() //if this is not a void method, handle the return
            QuorumOpcode right = opcodeStack:Pop()

            Operation returnOp
            returnOp:SetOperation(returnOp:RETURN)

            TypeChecker checker = GetTypeChecker()
            TypeCheckResult result = checker:Check(type, right:GetType(), returnOp) 

            ReturnOpcode opcode = cast(ReturnOpcode, result:GetQuorumOpcode())
            opcode:SetMethodWriter(methodWriter)
            currentBlockOpcode:Add(opcode)
        else //if it is a void method, just do a normal return, but don't pop off the opcode stack
            ReturnOpcode opcode
            opcode:SetType(type)
            opcode:SetMethodWriter(methodWriter)
            currentBlockOpcode:Add(opcode)
        end
    end

    action EnterParentCall(ParentCallContext context)
        a =5
    end
    action ExitParentCall(ParentCallContext context)
        a =5
    end

    action PushThis

    end

    action ExitInequality(InequalityContext context) 
        TypeChecker checker = GetTypeChecker()
        QuorumOpcode right = opcodeStack:Pop()
        QuorumOpcode left = opcodeStack:Pop()
        Operation add
        if context:isGreater
            add:SetOperation(add:GREATER)
        elseif context:isGreaterEquals
            add:SetOperation(add:GREATER_EQUALS)
        elseif context:isLess
            add:SetOperation(add:LESS)
        elseif context:isLessEquals
            add:SetOperation(add:LESS_EQUALS)
        end
        
        TypeCheckResult result = checker:Check(left:GetType(), right:GetType(), add)
        Type value = result:result
        ComparisonOpcode compare = cast(ComparisonOpcode, result:GetQuorumOpcode())
        compare:SetMethodWriter(methodWriter)
        compare:SetType(value)
        compare:SetLeftOpcode(left)
        compare:SetRightOpcode(right)
        opcodeStack:Push(compare)
    end

    action ExitEquals (EqualsContext context)
        TypeChecker checker = GetTypeChecker()
        QuorumOpcode right = opcodeStack:Pop()
        QuorumOpcode left = opcodeStack:Pop()
        Operation add
        if context:equalsTo
            add:SetOperation(add:EQUALS)
        else
            add:SetOperation(add:NOT_EQUALS)
        end
        
        TypeCheckResult result = checker:Check(left:GetType(), right:GetType(), add)
        Type value = result:result
        ComparisonOpcode compare = cast(ComparisonOpcode, result:GetQuorumOpcode())
        compare:SetMethodWriter(methodWriter)
        compare:SetType(value)
        compare:SetLeftOpcode(left)
        compare:SetRightOpcode(right)
        opcodeStack:Push(compare)
    end

    action EnterAnd(AndOrContext context) end
    action ExitAnd(AndOrContext context) 
        DoAndOr(context)
    end

    action DoAndOr(AndOrContext context)
        TypeChecker checker = GetTypeChecker()
        QuorumOpcode right = opcodeStack:Pop()
        QuorumOpcode left = opcodeStack:Pop()
        Operation op
        if context:isAnd
            op:SetOperation(op:AND)
        else 
            op:SetOperation(op:OR)
        end

        TypeCheckResult result = checker:Check(left:GetType(), right:GetType(), op)
        Type value = result:result
        BinaryAndOrOpcode binary
        binary:isAnd = context:isAnd
        binary:methodWriter = methodWriter
        binary:SetType(value)
        binary:left = left
        binary:right = right

        if left is BinaryAndOrOpcode
            BinaryAndOrOpcode theAnd = cast(BinaryAndOrOpcode, left)
            theAnd:hasParent = true
            theAnd:opcodeParent = binary
            theAnd:isOnLeft = true
        end

        if right is BinaryAndOrOpcode
            BinaryAndOrOpcode theAnd = cast(BinaryAndOrOpcode, right)
            theAnd:hasParent = true
            theAnd:opcodeParent = binary
            theAnd:isOnLeft = false
        end
        opcodeStack:Push(binary)
    end

    action EnterOr(AndOrContext context) end
    action ExitOr(AndOrContext context)
        DoAndOr(context)
    end

    action ExitMultiplication(MultiplicationContext context) 
        TypeChecker checker = GetTypeChecker()
        QuorumOpcode right = opcodeStack:Pop()
        QuorumOpcode left = opcodeStack:Pop()
        Operation op
        if context:isDivide
            op:SetOperation(op:DIVIDE)
        elseif context:isMultiply
            op:SetOperation(op:TIMES)
        else
            op:SetOperation(op:MODULUS)
        end

        TypeCheckResult result = checker:Check(left:GetType(), right:GetType(), op)
        Type value = result:result
        BinaryOpcode binary = cast(BinaryOpcode, result:GetQuorumOpcode())
        binary:SetMethodWriter(methodWriter)
        binary:SetType(value)
        binary:SetLeftOpcode(left)
        binary:SetRightOpcode(right)
        opcodeStack:Push(binary)
    end

    action ExitAddition(AdditionContext addition) 
        TypeChecker checker = GetTypeChecker()
        QuorumOpcode right = opcodeStack:Pop()
        QuorumOpcode left = opcodeStack:Pop()
        Operation add
        if addition:isPlus
            add:SetOperation(add:PLUS)
        else
            add:SetOperation(add:MINUS)
        end

        TypeCheckResult result = checker:Check(left:GetType(), right:GetType(), add)
        Type value = result:result
        BinaryOpcode binary = cast(BinaryOpcode, result:GetQuorumOpcode())
        binary:SetMethodWriter(methodWriter)
        binary:SetType(value)
        binary:SetLeftOpcode(left)
        binary:SetRightOpcode(right)
        opcodeStack:Push(binary)
    end

    action ExitMinus(UnaryMinusContext context) 
        TypeChecker checker = GetTypeChecker()
        QuorumOpcode left = opcodeStack:Pop()

        Operation notOp
        notOp:SetOperation(notOp:MINUS)
        TypeCheckResult result = checker:Check(left:GetType(), notOp) 
        Type value = result:result
        NegateUnaryOpcode binary = cast(NegateUnaryOpcode, result:GetQuorumOpcode())
        binary:SetMethodWriter(methodWriter)
        binary:SetType(value)
        binary:SetOpcode(left)
        opcodeStack:Push(binary)
    end

    action ExitNot(NotContext context) 
        TypeChecker checker = GetTypeChecker()
        QuorumOpcode left = opcodeStack:Pop()

        Operation notOp
        notOp:SetOperation(notOp:NOT)
        TypeCheckResult result = checker:Check(left:GetType(), notOp) 
        Type value = result:result
        FlipBooleanOpcode binary = cast(FlipBooleanOpcode, result:GetQuorumOpcode())
        binary:SetMethodWriter(methodWriter)
        binary:SetType(value)
        binary:SetOpcode(left)
        opcodeStack:Push(binary)
    end

    action ExitInteger(IntegerContext context) 
        Type type
        type:SetIsConstant(true)
        type:SetIntegerConstant(context:value)

        QuorumConstant const
        const:SetMethodWriter(methodWriter)
        const:SetType(type)
        const:integerValue = context:value
        opcodeStack:Push(const)
    end
    
    action ExitText(TextContext context) 
        Type type
        type:SetIsConstant(true)
        type:SetTextConstant(context:value)

        QuorumConstant const
        const:SetMethodWriter(methodWriter)
        const:SetType(type)
        const:textValue = context:value
        opcodeStack:Push(const)
    end

    action ExitBoolean(BooleanContext context) 
        Type type
        type:SetIsConstant(true)
        type:SetBooleanConstant(context:value)

        QuorumConstant const
        const:SetMethodWriter(methodWriter)
        const:SetType(type)
        const:booleanValue = context:value
        opcodeStack:Push(const)
    end

    action ExitNumber(NumberContext context) 
        Type type
        type:SetIsConstant(true)
        type:SetNumberConstant(context:value)

        QuorumConstant const
        const:SetMethodWriter(methodWriter)
        const:SetType(type)
        const:numberValue = context:value
        opcodeStack:Push(const)
    end
end